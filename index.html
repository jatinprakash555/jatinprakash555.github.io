<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive TCC Algorithm Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Firebase SDKs -->
    <script type="module">
        // Import all necessary Firebase functions at the top level for better performance and organization.
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, query, orderBy, limit, addDoc, getDocs, deleteDoc, doc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global Firebase variables accessible in the main script
        window.firebaseApp = null;
        window.db = null;
        window.auth = null;
        window.userId = null;
        window.isAuthReady = false;
        
        // Expose Firestore functions to the global scope for use in the main script tag.
        window.firestore = { collection, query, orderBy, limit, addDoc, getDocs, deleteDoc, doc };

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-tcc-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Initialize Firebase
        if (Object.keys(firebaseConfig).length > 0) {
            window.firebaseApp = initializeApp(firebaseConfig);
            window.db = getFirestore(window.firebaseApp);
            window.auth = getAuth(window.firebaseApp);
            setLogLevel('debug'); // Enable Firestore debug logging

            onAuthStateChanged(window.auth, async (user) => {
                if (user) {
                    window.userId = user.uid;
                    console.log("Firebase: User signed in:", window.userId);
                } else {
                    console.log("Firebase: No user signed in. Attempting sign-in.");
                    try {
                        if (initialAuthToken) {
                            await signInWithCustomToken(window.auth, initialAuthToken);
                        } else {
                            await signInAnonymously(window.auth);
                        }
                        window.userId = window.auth.currentUser?.uid || crypto.randomUUID();
                        console.log("Firebase: Sign-in successful or user ID set:", window.userId);
                    } catch (error) {
                        console.error("Firebase: Sign-in failed:", error);
                        window.userId = crypto.randomUUID(); // Ensure a userId even if auth fails
                    }
                }
                window.isAuthReady = true;
                document.dispatchEvent(new CustomEvent('firebaseAuthReady')); // Notify main script
            });
        } else {
            console.warn("Firebase config not found. Running without Firestore persistence.");
            window.userId = crypto.randomUUID(); // Generate a random ID for local operation
            window.isAuthReady = true;
            document.dispatchEvent(new CustomEvent('firebaseAuthReady'));
        }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!--  
        CONFIRMATION: NO SVG graphics used. NO Mermaid JS used.
    -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f9ff; /* sky-50 */
            color: #075985; /* sky-800 */
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            height: 300px;
            max-height: 400px;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 350px;
            }
        }
        .step-card.active {
            border-color: #fb923c; /* orange-400 */
            transform: translateY(-5px);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        #globeCanvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        #globeCanvas:active {
            cursor: grabbing;
        }
        .globe-container {
            position: relative;
            width: 100%;
            max-width: 800px; 
            height: 500px; 
            margin-left: auto;
            margin-right: auto;
            background-color: #e0f2fe; /* blue-50 */
            border-radius: 1rem;
            overflow: hidden; 
        }
        .globe-controls {
            position: absolute;
            top: 1rem;
            left: 1rem;
            right: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none; 
        }
        .globe-controls > * {
            pointer-events: auto; 
        }
        .compass {
            font-size: 1.5rem;
            font-weight: bold;
            color: #ef4444; /* red-500 */
            background-color: rgba(255, 255, 255, 0.7);
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .color-box {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            display: inline-block;
            vertical-align: middle;
            margin-right: 8px;
            border: 1px solid rgba(0,0,0,0.1);
        }
        /* Toggle Switch Styling */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #2196F3;
        }
        input:checked + .slider:before {
            transform: translateX(26px);
        }
        .toggle-text {
            position: absolute;
            transform: translate(-50%, -50%);
            top: 50%;
            left: 50%;
            font-size: 0.75rem;
            font-weight: bold;
            color: white;
            pointer-events: none;
            z-index: 1;
        }
        .toggle-text.left { left: 25%; color: #333; }
        .toggle-text.right { left: 75%; color: white; }
        input:checked + .slider .toggle-text.left { color: white; }
        input:checked + .slider .toggle-text.right { color: #333; }
        
        /* Spinner for LLM Q&A */
        .llm-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #3b82f6; /* Tailwind blue-500 */
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Tabs styling */
        .tab-button.active {
            border-bottom: 3px solid #fb923c; /* orange-400 */
            color: #fb923c;
        }
        /* Loading overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(240, 249, 255, 0.8); /* sky-50 with transparency */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: #075985;
            font-weight: bold;
        }
        .loading-spinner {
            border: 8px solid rgba(7, 89, 133, 0.1);
            border-top: 8px solid #0ea5e9; /* blue-500 */
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1.5s linear infinite;
            margin-bottom: 16px;
        }
        /* Custom modal for confirm() replacement */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .modal-content {
            background-color: #fff;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            text-align: center;
            max-width: 90%;
            width: 400px;
        }
    </style>
</head>
<body class="antialiased">

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay hidden">
        <div class="loading-spinner"></div>
        <p>Loading data...</p>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirmationModal" class="modal-overlay hidden">
        <div class="modal-content">
            <p id="modalMessage" class="text-xl font-semibold text-gray-800 mb-6">Are you sure?</p>
            <div class="flex justify-center gap-4">
                <button id="modalConfirmBtn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-full transition-transform transform hover:scale-105">Yes</button>
                <button id="modalCancelBtn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-6 rounded-full transition-transform transform hover:scale-105">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Header -->
    <header class="bg-white/80 backdrop-blur-sm sticky top-0 z-50 shadow-md">
        <nav class="container mx-auto px-6 py-3 flex justify-between items-center">
            <div class="text-2xl font-bold text-sky-700">🛰️ TCC Explorer</div>
            <div class="hidden md:flex space-x-6">
                <a href="#overview" class="text-gray-600 hover:text-sky-600 transition">Overview</a>
                <a href="#methodology" class="text-gray-600 hover:text-sky-600 transition">Methodology</a>
                <a href="#globe-view" class="text-gray-600 hover:text-sky-600 transition">Global TCC View</a>
                <a href="#cluster-dashboard" class="text-gray-600 hover:text-sky-600 transition">Cluster Dashboard</a>
                <a href="#outcomes" class="text-gray-600 hover:text-sky-600 transition">Outcomes</a>
                <a href="#llm-qa" class="text-gray-600 hover:text-sky-600 transition">AI Q&A</a>
                <a href="#evaluation" class="text-gray-600 hover:text-sky-600 transition">Evaluation</a>
            </div>
            <div class="md:hidden">
                <select id="mobile-nav" class="bg-white border border-gray-300 rounded-md p-2 text-gray-700">
                    <option value="#overview">Overview</option>
                    <option value="#methodology">Methodology</option>
                    <option value="#globe-view">Global TCC View</option>
                    <option value="#cluster-dashboard">Cluster Dashboard</option>
                    <option value="#outcomes">Outcomes</option>
                    <option value="#llm-qa">AI Q&A</option>
                    <option value="#evaluation">Evaluation</option>
                </select>
            </div>
        </nav>
    </header>

    <!-- Main Content -->
    <main class="container mx-auto px-6 py-12">

        <!-- Section: Overview -->
        <section id="overview" class="text-center mb-20">
            <h1 class="text-4xl md:text-5xl font-extrabold text-sky-800 mb-4">AI-Powered Tropical Cloud Cluster Identification</h1>
            <p class="max-w-3xl mx-auto text-lg text-sky-700">
                An interactive exploration of the AI/ML algorithm designed to detect, characterize, and track Tropical Cloud Clusters (TCCs) from INSAT-3D satellite data, a critical task for weather and climate system analysis.
            </p>
        </section>

        <!-- Section: Interactive Methodology -->
        <section id="methodology" class="mb-20">
            <h2 class="text-3xl font-bold text-center mb-2 text-sky-800">The Algorithm Unpacked</h2>
            <p class="text-center text-lg text-sky-700 mb-10">This is a step-by-step interactive guide to the TCC identification process. Click on each step to see the details.</p>
            
            <div class="flex flex-col md:flex-row flex-wrap justify-center items-start gap-4">
                <!-- Step Navigation -->
                <div class="w-full md:w-1/3 grid grid-cols-2 md:grid-cols-1 gap-4">
                    <div id="step-btn-1" class="step-card active cursor-pointer border-2 border-transparent bg-white p-4 rounded-lg shadow-lg hover:shadow-xl transition-all duration-300">
                        <h3 class="font-bold text-sky-600">1. Data Ingestion</h3>
                        <p class="text-sm text-gray-500">Loading satellite data.</p>
                    </div>
                    <div id="step-btn-2" class="step-card cursor-pointer border-2 border-transparent bg-white p-4 rounded-lg shadow-lg hover:shadow-xl transition-all duration-300">
                        <h3 class="font-bold text-sky-600">2. Candidate ID</h3>
                        <p class="text-sm text-gray-500">Filtering by size & intensity.</p>
                    </div>
                    <div id="step-btn-3" class="step-card cursor-pointer border-2 border-transparent bg-white p-4 rounded-lg shadow-lg hover:shadow-xl transition-all duration-300">
                        <h3 class="font-bold text-sky-600">3. Independence</h3>
                        <p class="text-sm text-gray-500">Grouping parent clusters.</p>
                    </div>
                    <div id="step-btn-4" class="step-card cursor-pointer border-2 border-transparent bg-white p-4 rounded-lg shadow-lg hover:shadow-xl transition-all duration-300">
                        <h3 class="font-bold text-sky-600">4. Tracking</h3>
                        <p class="text-sm text-gray-500">Following TCC movement.</p>
                    </div>
                </div>

                <!-- Step Details -->
                <div class="w-full md:w-1/2 bg-white p-8 rounded-lg shadow-2xl">
                    <div id="step-content">
                        <!-- JS will populate this -->
                    </div>
                </div>
            </div>
        </section>

        <!-- Section: Global TCC View -->
        <section id="globe-view" class="mb-20">
            <h2 class="text-3xl font-bold text-center mb-2 text-sky-800">Global TCC View</h2>
            <p class="text-center text-lg text-sky-700 mb-6">Explore the simulated Tropical Cloud Clusters on an interactive globe. Data updates automatically.</p>
            <div class="globe-container shadow-2xl border border-blue-200">
                <canvas id="globeCanvas"></canvas>
                <div class="globe-controls">
                    <div class="compass">N</div>
                    <button id="resetGlobeBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-full shadow-md transition-transform transform hover:scale-105">
                        Reset View
                    </button>
                </div>
            </div>
            <div class="flex flex-col md:flex-row justify-center items-center gap-4 mt-4">
                <div class="text-center text-lg text-sky-700">
                    <p>Latitude: <span id="current-latitude">0.00</span>°</p>
                    <p>Longitude: <span id="current-longitude">0.00</span>°</p>
                </div>
                <div class="flex flex-wrap justify-center gap-2">
                    <button data-mode="visible" class="globe-mode-btn bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-full text-sm transition">Visible</button>
                    <button data-mode="infrared" class="globe-mode-btn bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-2 px-4 rounded-full text-sm transition">Infrared</button>
                    <button data-mode="water-vapor" class="globe-mode-btn bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-2 px-4 rounded-full text-sm transition">Water Vapor</button>
                    <button data-mode="cloud-clusters" class="globe-mode-btn bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-2 px-4 rounded-full text-sm transition">Cloud Clusters</button>
                </div>
            </div>
            <div class="flex flex-col md:flex-row justify-center items-center gap-4 mt-4">
                <div class="flex flex-col items-center">
                    <label for="satellite-select" class="text-sky-700 font-semibold mb-2">Select Satellite Data:</label>
                    <select id="satellite-select" class="p-2 border border-gray-300 rounded-md shadow-sm text-gray-800">
                        <option value="INSAT-3D">INSAT-3D (Simulated)</option>
                        <option value="GOES-16">GOES-16 (Simulated)</option>
                        <option value="Himawari-8">Himawari-8 (Simulated)</option>
                        <option value="Meteosat-11">Meteosat-11 (Simulated)</option>
                    </select>
                </div>
                <button id="downloadAnalysisBtn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-full shadow-md transition-transform transform hover:scale-105">
                    Download Analysis
                </button>
            </div>
            <div class="flex justify-center mt-4">
                <button id="clearDataBtn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-full shadow-md transition-transform transform hover:scale-105">
                    Clear Historical Data
                </button>
            </div>
            <p class="text-center text-sm text-gray-500 mt-2">Last Updated: <span id="last-updated"></span></p>

            <!-- Color Identifier Legend -->
            <div class="mt-8 p-4 bg-white rounded-lg shadow-md max-w-md mx-auto text-left">
                <h3 class="text-xl font-bold text-sky-700 mb-3 text-center">Map Legend</h3>
                <div class="flex items-center mb-2">
                    <span class="color-box bg-[#1e90ff]"></span>
                    <span class="text-gray-700">Oceans (Deep Blue to Royal Blue)</span>
                </div>
                <div class="flex items-center mb-2">
                    <span class="color-box" style="background-color: #228B22;"></span>
                    <span class="text-gray-700">Major Landmasses (Various Greens & Browns)</span>
                </div>
                <div class="flex items-center">
                    <span class="color-box bg-white border border-gray-300"></span>
                    <span class="text-gray-700">Tropical Cloud Clusters (White/Light Blue)</span>
                </div>
            </div>
        </section>

        <!-- Section: Identified Clusters Dashboard -->
        <section id="cluster-dashboard" class="mb-20">
            <h2 class="text-3xl font-bold text-center mb-2 text-sky-800">Identified Clusters Dashboard</h2>
            <p class="text-center text-lg text-sky-700 mb-10">Dive deeper into the characteristics and performance metrics of the identified TCCs.</p>
            
            <div class="bg-white/60 p-6 rounded-xl shadow-lg border border-gray-200">
                <!-- Tabs for Dashboard -->
                <div class="flex justify-center border-b border-gray-300 mb-6">
                    <button data-tab="details" class="tab-button active py-3 px-6 text-lg font-semibold text-gray-600 hover:text-sky-600 transition">Cluster Details</button>
                    <button data-tab="temp-profile" class="tab-button py-3 px-6 text-lg font-semibold text-gray-600 hover:text-sky-600 transition">Temperature Profile</button>
                    <button data-tab="climate-explorer" class="tab-button py-3 px-6 text-lg font-semibold text-gray-600 hover:text-sky-600 transition">Climate Explorer</button>
                    <button data-tab="training-metrics" class="tab-button py-3 px-6 text-lg font-semibold text-gray-600 hover:text-sky-600 transition">Training Metrics</button>
                </div>

                <!-- Tab Content -->
                <div id="tab-content-details" class="tab-content">
                    <h3 class="text-2xl font-bold text-sky-700 mb-4">Recent TCC Detections</h3>
                    <div id="cluster-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        <!-- Cluster cards will be dynamically inserted here -->
                    </div>
                </div>

                <div id="tab-content-temp-profile" class="tab-content hidden">
                    <h3 class="text-2xl font-bold text-sky-700 mb-4">Typical TCC Temperature Profile</h3>
                    <p class="text-gray-700 mb-4">This chart shows a simulated vertical temperature profile within a mature Tropical Cloud Cluster.</p>
                    <div class="chart-container">
                        <canvas id="tempProfileChart"></canvas>
                    </div>
                </div>

                <div id="tab-content-climate-explorer" class="tab-content hidden">
                    <h3 class="text-2xl font-bold text-sky-700 mb-4">Climate Parameter Impact Explorer</h3>
                    <p class="text-gray-700 mb-4">Adjust the sliders to see the simulated impact of various climate parameters on TCC activity.</p>
                    <div class="p-4 bg-blue-50 rounded-lg shadow-inner">
                        <div class="mb-4">
                            <label for="sst-slider" class="block text-sky-700 font-semibold mb-2">Sea Surface Temperature (°C): <span id="sst-value">28</span></label>
                            <input type="range" id="sst-slider" min="25" max="32" value="28" step="0.1" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer">
                        </div>
                        <div class="mb-4">
                            <label for="wind-shear-slider" class="block text-sky-700 font-semibold mb-2">Vertical Wind Shear (m/s): <span id="wind-shear-value">10</span></label>
                            <input type="range" id="wind-shear-slider" min="5" max="20" value="10" step="0.5" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer">
                        </div>
                        <div class="mb-4">
                            <label for="humidity-slider" class="block text-sky-700 font-semibold mb-2">Mid-Level Humidity (%): <span id="humidity-value">70</span></label>
                            <input type="range" id="humidity-slider" min="50" max="90" value="70" step="1" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer">
                        </div>
                        <p class="text-center text-lg font-bold mt-6">Simulated TCC Activity Likelihood: <span id="tcc-likelihood" class="text-sky-800">Moderate</span></p>
                    </div>
                </div>

                <div id="tab-content-training-metrics" class="tab-content hidden">
                    <h3 class="text-2xl font-bold text-sky-700 mb-4">AI Model Training Metrics</h3>
                    <p class="text-gray-700 mb-4">Visualizing the performance of the TCC identification model during training.</p>
                    <div class="chart-container">
                        <canvas id="trainingMetricsChart"></canvas>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section: Expected Outcomes -->
        <section id="outcomes" class="mb-20">
            <h2 class="text-3xl font-bold text-center mb-2 text-sky-800">Expected Outcomes Dashboard</h2>
            <p class="text-center text-lg text-sky-700 mb-10">The algorithm generates a rich set of variables for each TCC. Here’s a sample visualization of a single identified cluster, updated periodically.</p>
            
            <div class="bg-white/60 p-6 rounded-xl shadow-lg border border-gray-200">
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8 text-center" id="outcome-cards">
                    <div class="bg-sky-50 p-4 rounded-lg">
                        <p class="text-sm text-sky-600">Mean Temp (Tb)</p>
                        <p class="text-2xl font-bold text-sky-800" id="mean-temp">225.4 K</p>
                        <label class="toggle-switch mt-2">
                            <input type="checkbox" id="tempUnitToggle">
                            <span class="slider">
                                <span class="toggle-text left">K</span>
                                <span class="toggle-text right">°C</span>
                            </span>
                        </label>
                    </div>
                    <div class="bg-sky-50 p-4 rounded-lg">
                        <p class="text-sm text-sky-600">Min Temp (Tb)</p>
                        <p class="text-2xl font-bold text-sky-800" id="min-temp">198.1 K</p>
                    </div>
                    <div class="bg-sky-50 p-4 rounded-lg">
                        <p class="text-sm text-sky-600">Mean Radius</p>
                        <p class="text-2xl font-bold text-sky-800" id="mean-radius">152 km</p>
                    </div>
                    <div class="bg-sky-50 p-4 rounded-lg">
                        <p class="text-sm text-sky-600">Mean Cld Height</p>
                        <p class="text-2xl font-bold text-sky-800" id="mean-cloud-height">14.2 km</p>
                    </div>
                </div>

                <!-- Area Stats Checker -->
                <div class="mt-8 p-6 bg-blue-50 rounded-lg shadow-md border border-blue-200">
                    <h3 class="text-xl font-bold text-sky-700 mb-4 text-center">TCC Area Checker</h3>
                    <p class="text-gray-700 mb-4 text-center">Enter an area (in km²) to check if it meets the minimum TCC size requirement (34,800 km²).</p>
                    <div class="flex flex-col md:flex-row items-center justify-center gap-4">
                        <input
                            type="number"
                            id="areaInput"
                            placeholder="e.g., 40000"
                            class="flex-grow p-3 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-800 max-w-xs w-full"
                        >
                        <button
                            id="checkAreaBtn"
                            class="bg-orange-500 hover:bg-orange-600 text-white font-bold py-3 px-8 rounded-full shadow-lg transition-transform transform hover:scale-105 duration-300"
                        >
                            Check Area
                        </button>
                    </div>
                    <p id="areaCheckResult" class="text-center mt-4 font-medium text-gray-800"></p>
                </div>

                <div class="chart-container mt-8">
                    <canvas id="outcomesRadarChart"></canvas>
                </div>
            </div>
        </section>

        <!-- Section: LLM Q&A -->
        <section id="llm-qa" class="mb-20">
            <h2 class="text-3xl font-bold text-center mb-2 text-sky-800">✨ Algorithm Q&A ✨</h2>
            <p class="text-center text-lg text-sky-700 mb-6">Ask our AI assistant any question about the TCC identification algorithm or related concepts.</p>
            <div class="bg-white/60 p-6 rounded-xl shadow-lg border border-blue-200 max-w-2xl mx-auto">
                <textarea
                    id="qaInput"
                    class="w-full p-3 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-sky-500 text-gray-800 mb-4"
                    rows="4"
                    placeholder="e.g., What is IRBRT data? How is TCC independence determined?"
                ></textarea>
                <button
                    id="askAiBtn"
                    class="bg-sky-600 hover:bg-sky-700 text-white font-bold py-3 px-8 rounded-full shadow-lg transition-transform transform hover:scale-105 duration-300 flex items-center justify-center mx-auto"
                >
                    Ask AI
                </button>
                <div id="qaLoadingSpinner" class="hidden flex justify-center items-center py-4 mt-4">
                    <div class="llm-spinner"></div>
                    <span class="ml-3 text-sky-600 font-medium">AI is thinking...</span>
                </div>
                <div
                    id="qaOutput"
                    class="bg-white p-4 rounded-lg shadow-inner border border-gray-200 min-h-[100px] text-gray-700 mt-6 whitespace-pre-wrap"
                >
                    Your AI answers will appear here.
                </div>
            </div>
        </section>

        <!-- Section: Evaluation -->
        <section id="evaluation">
            <h2 class="text-3xl font-bold text-center mb-10 text-sky-800">Evaluation Criteria</h2>
            <div class="grid md:grid-cols-3 gap-8">
                <div class="bg-white p-6 rounded-lg shadow-md border border-gray-200">
                    <h3 class="text-2xl font-bold text-sky-700 mb-3">🎯 Accuracy</h3>
                    <p class="text-gray-600">Precision of the retrieved data against ground truth. Evaluates correctness of TCC identification, characterization, and tracking.</p>
                </div>
                <div class="bg-white p-6 rounded-lg shadow-md border border-gray-200">
                    <h3 class="text-2xl font-bold text-sky-700 mb-3">✅ Relevance</h3>
                    <p class="text-gray-600">The degree to which identified TCCs align with meteorological definitions and their utility for forecasting and research.</p>
                </div>
                <div class="bg-white p-6 rounded-lg shadow-md border border-gray-200">
                    <h3 class="text-2xl font-bold text-sky-700 mb-3">🧑‍💻 User Experience</h3>
                    <p class="text-gray-600">The ease of use, speed, and overall satisfaction for researchers and forecasters using the generated ITCC dataset.</p>
                </div>
            </div>
        </section>

    </main>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Global Variables and Constants ---
            const loadingOverlay = document.getElementById('loadingOverlay');
            const confirmationModal = document.getElementById('confirmationModal');
            const modalMessage = document.getElementById('modalMessage');
            const modalConfirmBtn = document.getElementById('modalConfirmBtn');
            const modalCancelBtn = document.getElementById('modalCancelBtn');
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-tcc-app-id';

            // --- Utility Functions ---
            const showLoading = (message = "Loading data...") => {
                loadingOverlay.querySelector('p').textContent = message;
                loadingOverlay.classList.remove('hidden');
            };

            const hideLoading = () => {
                loadingOverlay.classList.add('hidden');
            };
            
            // Replaces window.confirm with a promise-based custom modal
            const showConfirmationModal = (message, onConfirm) => {
                modalMessage.textContent = message;
                confirmationModal.classList.remove('hidden');
                return new Promise((resolve) => {
                    const confirmHandler = () => {
                        cleanup();
                        resolve(true);
                    };
                    const cancelHandler = () => {
                        cleanup();
                        resolve(false);
                    };
                    const cleanup = () => {
                        modalConfirmBtn.removeEventListener('click', confirmHandler);
                        modalCancelBtn.removeEventListener('click', cancelHandler);
                        confirmationModal.classList.add('hidden');
                    };
                    modalConfirmBtn.addEventListener('click', confirmHandler);
                    modalCancelBtn.addEventListener('click', cancelHandler);
                });
            };

            // --- Initialization ---
            showLoading("Initializing application...");

            document.addEventListener('firebaseAuthReady', async () => {
                console.log("Firebase Auth is ready. User ID:", window.userId);
                await loadHistoricalClusters(); // Load historical data first
                updateAllData(); // Then perform initial data update
                setInterval(updateAllData, 1800000); // Update every 30 minutes
                hideLoading();
            });

            // --- Section Navigation Logic ---
            const mobileNav = document.getElementById('mobile-nav');
            mobileNav.addEventListener('change', (e) => {
                const targetId = e.target.value;
                const targetElement = document.querySelector(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({ behavior: 'smooth' });
                }
            });

            // --- Interactive Methodology Section Logic ---
            const stepContent = document.getElementById('step-content');
            const stepButtons = document.querySelectorAll('.step-card');
            const stepsData = {
                '1': {
                    title: 'Step 1: Data Preprocessing and Ingestion',
                    content: `<p class="mb-4 text-gray-700">The process begins by loading half-hourly INSAT-3D Infrared Brightness Temperature (IRBRT) data. Each satellite image must be properly georeferenced to map pixel coordinates to their real-world latitude and longitude.</p><ul class="list-disc list-inside text-gray-600 space-y-2"><li><strong>Source:</strong> INSAT-3D Satellite</li><li><strong>Data Type:</strong> Infrared Brightness Temperature (IRBRT)</li><li><strong>Frequency:</strong> Half-hourly</li><li><strong>Key Action:</strong> Georeferencing & Normalization</li></ul>`
                },
                '2': {
                    title: 'Step 2: TCC Candidate Identification',
                    content: `<p class="mb-4 text-gray-700">TCC candidates are first identified by their temperature and size. A scene is filtered using a pre-determined IRBT threshold. Contiguous pixels that pass this filter are then evaluated based on size criteria.</p><ul class="list-disc list-inside text-gray-600 space-y-2"><li><strong>IRBT Threshold:</strong> Only pixels below a certain temperature pass.</li><li><strong>Minimum Radius:</strong> Must be at least <strong>1° (~111 km)</strong> in one direction.</li><li><strong>Minimum Area:</strong> Must cover at least <strong>34,800 km²</strong>.</li></ul>`
                },
                '3': {
                    title: 'Step 3: Independence Determination',
                    content: `<p class="mb-4 text-gray-700">TCCs can be complex systems. If multiple convective areas are close, the algorithm determines if they are independent or part of a larger 'parent' system.</p><ul class="list-disc list-inside text-gray-600 space-y-2"><li><strong>Proximity Rule:</strong> Candidates within <strong>1200 km</strong> of a larger 'parent' cluster are considered subsets of it.</li><li><strong>Distinct TCC:</strong> If a candidate is more than <strong>1200 km</strong> away, it is classified as a distinct system.</li></ul>`
                },
                '4': {
                    title: 'Step 4: TCC Tracking',
                    content: `<p class="mb-4 text-gray-700">Once a TCC is confirmed, the algorithm tracks its movement by searching back in time and matching it with previous records based on proximity.</p><div class="chart-container !h-[250px] md:!h-[300px] mt-4"><canvas id="trackingChart"></canvas></div>`
                },
            };
            
            let trackingChartInstance;
            const renderTrackingChart = () => {
                const ctx = document.getElementById('trackingChart').getContext('2d');
                if(trackingChartInstance) trackingChartInstance.destroy();
                trackingChartInstance = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['3 hrs', '6 hrs', '9 hrs', '12 hrs'],
                        datasets: [{
                            label: 'Search Radius (km)',
                            data: [450, 550, 600, 650],
                            backgroundColor: '#38bdf8',
                            borderColor: '#0ea5e9',
                            borderWidth: 1,
                            borderRadius: 5,
                        }]
                    },
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        plugins: {
                            title: { display: true, text: 'Tracking Search Radius vs. Time', color: '#0c4a6e' },
                            legend: { display: false }
                        },
                        scales: {
                            y: { beginAtZero: false, title: { display: true, text: 'Radius (km)', color: '#075985' } },
                            x: { title: { display: true, text: 'Time Since Last Location', color: '#075985' } }
                        }
                    }
                });
            };

            const updateStepContent = (step) => {
                const data = stepsData[step];
                stepContent.innerHTML = `<h3 class="text-2xl font-bold text-sky-800 mb-4">${data.title}</h3>${data.content}`;
                stepButtons.forEach((btn, index) => {
                    btn.classList.toggle('active', (index + 1) == step);
                });
                if (step == 4) renderTrackingChart();
            };
            
            stepButtons.forEach((button, index) => {
                button.addEventListener('click', () => updateStepContent(index + 1));
            });

            updateStepContent(1); // Initialize

            // --- Expected Outcomes Dashboard Logic ---
            let outcomesRadarChartInstance;
            const radarCtx = document.getElementById('outcomesRadarChart').getContext('2d');
            const renderOutcomesRadarChart = (data) => {
                if(outcomesRadarChartInstance) outcomesRadarChartInstance.destroy();
                outcomesRadarChartInstance = new Chart(radarCtx, {
                    type: 'radar',
                    data: {
                        labels: ['Mean Temp', 'Min Temp', 'Max Radius', 'Mean Radius', 'Max Cloud Height', 'Mean Cloud Height'],
                        datasets: [{
                            label: 'Sample TCC Characteristics (Normalized)',
                            data: data,
                            backgroundColor: 'rgba(56, 189, 248, 0.2)',
                            borderColor: '#0ea5e9',
                            pointBackgroundColor: '#0ea5e9',
                            pointBorderColor: '#fff',
                            pointHoverBackgroundColor: '#fff',
                            pointHoverBorderColor: '#0ea5e9'
                        }]
                    },
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        plugins: {
                            title: { display: true, text: 'Normalized Profile of a Sample TCC', color: '#0c4a6e' },
                            legend: { position: 'bottom' }
                        },
                        scales: {
                            r: {
                                angleLines: { color: 'rgba(7, 89, 133, 0.2)' },
                                grid: { color: 'rgba(7, 89, 133, 0.2)' },
                                pointLabels: { font: { size: 12 }, color: '#075985' },
                                ticks: { backdropColor: '#f0f9ff', color: '#0369a1', beginAtZero: true, min: 0, max: 1, stepSize: 0.2 }
                            }
                        }
                    }
                });
            };

            const meanTempElem = document.getElementById('mean-temp');
            const minTempElem = document.getElementById('min-temp');
            const meanRadiusElem = document.getElementById('mean-radius');
            const meanCloudHeightElem = document.getElementById('mean-cloud-height');
            const tempUnitToggle = document.getElementById('tempUnitToggle');
            let currentTempUnit = 'K';

            const kelvinToCelsius = (k) => (parseFloat(k) - 273.15).toFixed(1);

            const updateTCCDashboardData = () => {
                const newMeanTempK = (220 + Math.random() * 10).toFixed(1);
                const newMinTempK = (190 + Math.random() * 10).toFixed(1);
                const newMeanRadius = (100 + Math.random() * 100).toFixed(0);
                const newMeanCloudHeight = (12 + Math.random() * 4).toFixed(1);

                meanTempElem.dataset.kelvin = newMeanTempK;
                minTempElem.dataset.kelvin = newMinTempK;

                if (currentTempUnit === 'K') {
                    meanTempElem.textContent = `${newMeanTempK} K`;
                    minTempElem.textContent = `${newMinTempK} K`;
                } else {
                    meanTempElem.textContent = `${kelvinToCelsius(newMeanTempK)} °C`;
                    minTempElem.textContent = `${kelvinToCelsius(newMinTempK)} °C`;
                }
                
                meanRadiusElem.textContent = `${newMeanRadius} km`;
                meanCloudHeightElem.textContent = `${newMeanCloudHeight} km`;

                const normalizedData = [
                    (newMeanTempK - 210) / 20, (newMinTempK - 180) / 30,
                    (newMeanRadius - 50) / 200, (newMeanRadius - 50) / 200,
                    (newMeanCloudHeight - 10) / 10, (newMeanCloudHeight - 10) / 10
                ].map(val => Math.max(0, Math.min(1, val)));

                renderOutcomesRadarChart(normalizedData);
            };

            tempUnitToggle.addEventListener('change', () => {
                currentTempUnit = tempUnitToggle.checked ? 'C' : 'K';
                const currentMeanTempK = meanTempElem.dataset.kelvin;
                const currentMinTempK = minTempElem.dataset.kelvin;
                if (currentTempUnit === 'K') {
                    meanTempElem.textContent = `${currentMeanTempK} K`;
                    minTempElem.textContent = `${currentMinTempK} K`;
                } else {
                    meanTempElem.textContent = `${kelvinToCelsius(currentMeanTempK)} °C`;
                    minTempElem.textContent = `${kelvinToCelsius(currentMinTempK)} °C`;
                }
            });

            // Area Stats Checker Logic
            const areaInput = document.getElementById('areaInput');
            const checkAreaBtn = document.getElementById('checkAreaBtn');
            const areaCheckResult = document.getElementById('areaCheckResult');
            const MIN_TCC_AREA = 34800;
            checkAreaBtn.addEventListener('click', () => {
                const enteredArea = parseFloat(areaInput.value);
                if (isNaN(enteredArea)) {
                    areaCheckResult.textContent = "Please enter a valid number for the area.";
                    areaCheckResult.className = 'text-center mt-4 font-medium text-red-600';
                } else if (enteredArea >= MIN_TCC_AREA) {
                    areaCheckResult.textContent = `✅ ${enteredArea.toLocaleString()} km² meets the minimum TCC area requirement!`;
                    areaCheckResult.className = 'text-center mt-4 font-medium text-green-600';
                } else {
                    areaCheckResult.textContent = `❌ ${enteredArea.toLocaleString()} km² is below the minimum TCC area of ${MIN_TCC_AREA.toLocaleString()} km².`;
                    areaCheckResult.className = 'text-center mt-4 font-medium text-red-600';
                }
            });

            // --- LLM Q&A Logic ---
            const qaInput = document.getElementById('qaInput');
            const askAiBtn = document.getElementById('askAiBtn');
            const qaOutput = document.getElementById('qaOutput');
            const qaLoadingSpinner = document.getElementById('qaLoadingSpinner');
            askAiBtn.addEventListener('click', async () => {
                const question = qaInput.value.trim();
                if (!question) {
                    qaOutput.textContent = "Please enter a question to ask the AI.";
                    return;
                }
                qaLoadingSpinner.classList.remove('hidden');
                qaOutput.textContent = '';
                askAiBtn.disabled = true;
                try {
                    const prompt = `Based on the provided context about the 'AI/ML Algorithm for Identifying Tropical Cloud Clusters Using Half-Hourly Satellite Data from the INSAT', answer the following question: "${question}". Focus on explaining concepts related to the algorithm's methodology, objectives, expected outcomes, and evaluation parameters. If the question is outside this scope, state that you cannot answer it based on the provided information.`;
                    let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
                    const payload = { contents: chatHistory };
                    const apiKey = ""; 
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`API error: ${response.status} - ${errorData.error.message || 'Unknown error'}`);
                    }
                    const result = await response.json();
                    if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                        qaOutput.textContent = result.candidates[0].content.parts[0].text;
                    } else {
                        qaOutput.textContent = "Sorry, I couldn't generate an answer. Please try rephrasing your question.";
                    }
                } catch (error) {
                    console.error("Error asking AI:", error);
                    qaOutput.textContent = `An error occurred: ${error.message}. Please try again.`;
                } finally {
                    qaLoadingSpinner.classList.add('hidden');
                    askAiBtn.disabled = false;
                }
            });

            // --- Global TCC View Logic (Three.js) ---
            const globeContainer = document.querySelector('.globe-container');
            const globeCanvas = document.getElementById('globeCanvas');
            const lastUpdatedSpan = document.getElementById('last-updated');
            const resetGlobeBtn = document.getElementById('resetGlobeBtn');
            const currentLatitudeSpan = document.getElementById('current-latitude');
            const currentLongitudeSpan = document.getElementById('current-longitude');
            const globeModeButtons = document.querySelectorAll('.globe-mode-btn');
            const satelliteSelect = document.getElementById('satellite-select');
            const downloadAnalysisBtn = document.getElementById('downloadAnalysisBtn');
            const clearDataBtn = document.getElementById('clearDataBtn');
            let scene, camera, renderer, earthMesh;
            let isDragging = false, initialPinchDistance = 0;
            let previousMousePosition = { x: 0, y: 0 };
            const rotationSpeed = 0.005, zoomSpeed = 0.1;
            const minZoom = 7, maxZoom = 15;
            const initialRotation = { x: 0.2, y: 0.5 };
            let currentGlobeMode = 'visible', currentSatellite = 'INSAT-3D';

            function initGlobe() {
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, globeContainer.clientWidth / globeContainer.clientHeight, 0.1, 1000);
                renderer = new THREE.WebGLRenderer({ canvas: globeCanvas, antialias: true });
                renderer.setSize(globeContainer.clientWidth, globeContainer.clientHeight);
                renderer.setClearColor(0xf0f9ff, 1);

                const geometry = new THREE.SphereGeometry(5, 64, 64);
                const material = new THREE.MeshPhongMaterial({ shininess: 30, specular: 0x999999 });
                earthMesh = new THREE.Mesh(geometry, material);
                scene.add(earthMesh);

                scene.add(new THREE.AmbientLight(0xcccccc, 0.5));
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 3, 5).normalize();
                scene.add(directionalLight);

                camera.position.z = 10;
                earthMesh.rotation.x = initialRotation.x;
                earthMesh.rotation.y = initialRotation.y;

                // Event Listeners
                globeCanvas.addEventListener('mousedown', (e) => { isDragging = true; previousMousePosition = { x: e.clientX, y: e.clientY }; });
                globeCanvas.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    earthMesh.rotation.y += deltaX * rotationSpeed;
                    earthMesh.rotation.x += deltaY * rotationSpeed;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                    updateLatLonDisplay();
                });
                globeCanvas.addEventListener('mouseup', () => isDragging = false);
                globeCanvas.addEventListener('mouseleave', () => isDragging = false);
                globeCanvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    camera.position.z -= e.deltaY * 0.01 * zoomSpeed;
                    camera.position.z = Math.max(minZoom, Math.min(maxZoom, camera.position.z));
                });
                
                resetGlobeBtn.addEventListener('click', () => {
                    earthMesh.rotation.x = initialRotation.x;
                    earthMesh.rotation.y = initialRotation.y;
                    camera.position.z = 10;
                    updateLatLonDisplay();
                });

                globeModeButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        currentGlobeMode = button.dataset.mode;
                        updateGlobeTexture();
                        globeModeButtons.forEach(btn => btn.classList.remove('bg-blue-500', 'text-white'));
                        globeModeButtons.forEach(btn => btn.classList.add('bg-gray-200', 'text-gray-800'));
                        button.classList.add('bg-blue-500', 'text-white');
                        button.classList.remove('bg-gray-200', 'text-gray-800');
                    });
                });
                document.querySelector(`.globe-mode-btn[data-mode="${currentGlobeMode}"]`).click();

                satelliteSelect.addEventListener('change', (e) => {
                    currentSatellite = e.target.value;
                    updateGlobeTexture();
                    updateAllData();
                });

                downloadAnalysisBtn.addEventListener('click', downloadRecentAnalysis);
                clearDataBtn.addEventListener('click', async () => {
                    const userConfirmed = await showConfirmationModal('Are you sure you want to clear all historical data? This cannot be undone.');
                    if (userConfirmed) await clearHistoricalData();
                });

                animateGlobe();
                window.addEventListener('resize', onWindowResize);
                updateLatLonDisplay();
            }

            const onWindowResize = () => {
                camera.aspect = globeContainer.clientWidth / globeContainer.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(globeContainer.clientWidth, globeContainer.clientHeight);
            };

            const animateGlobe = () => {
                requestAnimationFrame(animateGlobe);
                renderer.render(scene, camera);
            };
            
            // Simplified Lat/Lon display - not geographically precise but gives a good feel.
            const updateLatLonDisplay = () => {
                let lat = (earthMesh.rotation.x * 180 / Math.PI) % 360;
                if (lat > 180) lat -= 360;
                if (lat < -180) lat += 360;
                if (lat > 90) lat = 180 - lat;
                if (lat < -90) lat = -180 - lat;
                let lon = (earthMesh.rotation.y * 180 / Math.PI) % 360;
                if (lon > 180) lon -= 360;
                if (lon < -180) lon += 360;
                currentLatitudeSpan.textContent = (-lat).toFixed(2); // Invert for more intuitive feel
                currentLongitudeSpan.textContent = lon.toFixed(2);
            };
            
            // --- Texture Generation ---
            // These functions create procedural textures for the globe to simulate different satellite views.
            function createSeededRandom(seed) {
                let x = Math.sin(seed) * 10000;
                return () => {
                    x = (x * 9301 + 49297) % 233280;
                    // The JS % operator can return a negative result.
                    // We ensure the number is positive before dividing to get a value in [0, 1).
                    const positiveResult = (x < 0) ? x + 233280 : x;
                    return positiveResult / 233280;
                };
            }
            
            function generateTexture(config) {
                const canvas = document.createElement('canvas');
                canvas.width = 2048; canvas.height = 1024;
                const ctx = canvas.getContext('2d');
                const w = canvas.width, h = canvas.height;

                // Background
                ctx.fillStyle = config.oceanColor;
                ctx.fillRect(0, 0, w, h);

                // Landmasses
                ctx.fillStyle = config.landColor;
                // Simplified landmass shapes
                ctx.fillRect(w*0.1, h*0.2, w*0.2, h*0.25); // N. America
                ctx.fillRect(w*0.18, h*0.45, w*0.1, h*0.3); // S. America
                ctx.fillRect(w*0.4, h*0.3, w*0.18, h*0.4); // Africa
                ctx.fillRect(w*0.55, h*0.1, w*0.4, h*0.4); // Eurasia
                ctx.fillRect(w*0.8, h*0.65, w*0.1, h*0.1); // Australia

                // Clouds
                const seededRandom = createSeededRandom(config.seed);
                ctx.globalAlpha = 0.7;
                for (let i = 0; i < 150 * config.cloudDensity; i++) {
                    const x = seededRandom() * w, y = seededRandom() * h;
                    const radius = 20 + seededRandom() * 80;
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                    gradient.addColorStop(0, config.cloudColor + 'ff');
                    gradient.addColorStop(1, config.cloudColor + '00');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
                }
                ctx.globalAlpha = 1.0;
                return new THREE.CanvasTexture(canvas);
            }

            const updateGlobeTexture = () => {
                const satelliteSeed = new Date().getHours() + currentSatellite.charCodeAt(0);
                const configs = {
                    'visible': { oceanColor: '#1e90ff', landColor: '#228B22', cloudColor: '#ffffff', cloudDensity: 1, seed: satelliteSeed + 1 },
                    'infrared': { oceanColor: '#333333', landColor: '#555555', cloudColor: '#ffffff', cloudDensity: 1.5, seed: satelliteSeed + 2 },
                    'water-vapor': { oceanColor: '#003366', landColor: '#336699', cloudColor: '#c8d8ff', cloudDensity: 1.2, seed: satelliteSeed + 3 },
                    'cloud-clusters': { oceanColor: '#AAAAAA', landColor: '#888888', cloudColor: '#ffffff', cloudDensity: 2, seed: satelliteSeed + 4 }
                };
                const newTexture = generateTexture(configs[currentGlobeMode]);
                if (earthMesh && earthMesh.material) {
                    if (earthMesh.material.map) earthMesh.material.map.dispose();
                    earthMesh.material.map = newTexture;
                    earthMesh.material.needsUpdate = true;
                }
            };

            // --- Data Management and Download ---
            let currentAnalysisData = {};
            let historicalClusters = [];
            async function downloadRecentAnalysis() {
                const analysisText = `TCC Algorithm Analysis Report - ${new Date().toLocaleString()}\nData Source: Simulated (Influenced by ${historicalClusters.length > 0 ? 'historical data' : 'random generation'})\n\n--- Global TCC View ---\nCurrent Globe Mode: ${currentGlobeMode}\nSelected Satellite Data: ${currentSatellite}\n\n--- Identified Clusters (Simulated) ---\n${currentAnalysisData.clusters ? currentAnalysisData.clusters.map(c => `ID: ${c.id}, Lat: ${c.lat}, Lon: ${c.lon}, Size: ${c.size} km², Min Temp: ${c.minTemp} K, Status: ${c.status}`).join('\n') : 'No clusters data available.'}`;
                const blob = new Blob([analysisText], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `TCC_Analysis_Report_${new Date().toISOString().slice(0,10)}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            // --- Identified Clusters Dashboard Logic ---
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabContents = document.querySelectorAll('.tab-content');
            const showTab = (tabId) => {
                tabContents.forEach(c => c.classList.add('hidden'));
                tabButtons.forEach(b => b.classList.remove('active'));
                document.getElementById(`tab-content-${tabId}`).classList.remove('hidden');
                document.querySelector(`.tab-button[data-tab="${tabId}"]`).classList.add('active');
                if (tabId === 'temp-profile') renderTempProfileChart();
                else if (tabId === 'training-metrics') renderTrainingMetricsChart();
            };
            tabButtons.forEach(button => button.addEventListener('click', () => showTab(button.dataset.tab)));
            showTab('details');

            // --- Firestore Functions ---
            const TCC_HISTORY_COLLECTION = 'tcc_history';
            const MAX_HISTORY_RECORDS = 5;

            async function saveClustersToFirestore(clusters) {
                if (!window.db || !window.userId) return;
                try {
                    const { collection, addDoc } = window.firestore;
                    const docPath = `artifacts/${appId}/users/${window.userId}/${TCC_HISTORY_COLLECTION}`;
                    await addDoc(collection(window.db, docPath), {
                        timestamp: new Date(),
                        clusters: clusters
                    });
                    console.log("Clusters saved to Firestore.");
                    // Pruning logic could be added here if needed
                } catch (e) {
                    console.error("Error saving clusters to Firestore: ", e);
                }
            }

            async function loadHistoricalClusters() {
                if (!window.db || !window.userId) return;
                showLoading("Loading historical data...");
                try {
                    const { collection, query, orderBy, limit, getDocs } = window.firestore;
                    const docPath = `artifacts/${appId}/users/${window.userId}/${TCC_HISTORY_COLLECTION}`;
                    const q = query(collection(window.db, docPath), orderBy('timestamp', 'desc'), limit(1));
                    const querySnapshot = await getDocs(q);
                    if (!querySnapshot.empty) {
                        historicalClusters = querySnapshot.docs[0].data().clusters;
                        console.log("Loaded historical clusters:", historicalClusters);
                    } else {
                        console.log("No historical clusters found.");
                    }
                } catch (e) {
                    console.error("Error loading historical clusters: ", e);
                } finally {
                    hideLoading();
                }
            }

            async function clearHistoricalData() {
                if (!window.db || !window.userId) return;
                showLoading("Clearing historical data...");
                try {
                    const { collection, getDocs, deleteDoc, doc } = window.firestore;
                    const docPath = `artifacts/${appId}/users/${window.userId}/${TCC_HISTORY_COLLECTION}`;
                    const querySnapshot = await getDocs(collection(window.db, docPath));
                    const deletePromises = querySnapshot.docs.map(d => deleteDoc(doc(window.db, docPath, d.id)));
                    await Promise.all(deletePromises);
                    historicalClusters = [];
                    console.log("All historical data cleared.");
                } catch (e) {
                    console.error("Error clearing historical data:", e);
                } finally {
                    hideLoading();
                    updateAllData();
                }
            }
            
            // --- Data Simulation and Rendering ---
            function generateSimulatedClusters(count, satellite) {
                // This function now uses historical data to influence new cluster generation
                // for a more persistent and realistic simulation.
                const statuses = ['Active', 'Developing', 'Dissipated'];
                const clusters = [];
                let lonOffset = { 'GOES-16': -90, 'Himawari-8': 140, 'Meteosat-11': 0, 'INSAT-3D': 75 }[satellite] || 75;

                const activeHistory = historicalClusters.filter(c => c.status !== 'Dissipated');
                const useHistory = activeHistory.length > 0 && Math.random() < 0.7; // 70% chance to follow history

                let avgLat = 0, avgLon = 0;
                if(useHistory) {
                    avgLat = activeHistory.reduce((sum, c) => sum + parseFloat(c.lat), 0) / activeHistory.length;
                    avgLon = activeHistory.reduce((sum, c) => sum + parseFloat(c.lon), 0) / activeHistory.length;
                }

                for (let i = 0; i < count; i++) {
                    const lat = useHistory ? (avgLat + (Math.random() * 20 - 10)) : (Math.random() * 60 - 30);
                    const lon = useHistory ? (avgLon + (Math.random() * 20 - 10)) : ((Math.random() * 60 - 30) + lonOffset);
                    
                    clusters.push({
                        id: `TCC-${Math.floor(1000 + Math.random() * 9000)}`,
                        lat: Math.max(-30, Math.min(30, lat)).toFixed(2),
                        lon: Math.max(-180, Math.min(180, lon)).toFixed(2),
                        size: (35000 + Math.random() * 100000).toFixed(0),
                        minTemp: (190 + Math.random() * 20).toFixed(1),
                        meanTemp: (210 + Math.random() * 20).toFixed(1),
                        maxCloudHeight: (10 + Math.random() * 8).toFixed(1),
                        status: statuses[Math.floor(Math.random() * statuses.length)]
                    });
                }
                return clusters;
            }

            async function getTccForecast(cluster, climateParams) {
                // This function now uses the Gemini API to generate a meteorological forecast
                showLoading("Generating AI forecast...");
                const prompt = `As a meteorologist, analyze this Tropical Cloud Cluster (TCC) data and provide a short, clear forecast (max 3 sentences).\nTCC Data:\n- Status: ${cluster.status}\n- Size: ${cluster.size} km²\n- Min Temp: ${cluster.minTemp} K\n- Max Cloud Height: ${cluster.maxCloudHeight} km\nEnvironmental Conditions:\n- SST: ${climateParams.sst} °C\n- Wind Shear: ${climateParams.windShear} m/s\n- Humidity: ${climateParams.humidity} %`;
                try {
                    let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
                    const payload = { contents: chatHistory };
                    const apiKey = "";
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (!response.ok) throw new Error(`API error: ${response.status}`);
                    const result = await response.json();
                    return result.candidates?.[0]?.content?.parts?.[0]?.text || "Forecast could not be generated.";
                } catch (error) {
                    console.error("Error generating AI forecast:", error);
                    return `Error generating forecast: ${error.message}`;
                } finally {
                    hideLoading();
                }
            }

            function renderClusterDetails(clusters) {
                const clusterListDiv = document.getElementById('cluster-list');
                clusterListDiv.innerHTML = '';
                if (clusters.length === 0) {
                    clusterListDiv.innerHTML = '<p class="text-center text-gray-600 col-span-full">No TCCs identified.</p>';
                    return;
                }
                clusters.forEach(cluster => {
                    const statusColor = { 'Active': 'text-green-600', 'Developing': 'text-yellow-600', 'Dissipated': 'text-red-600' }[cluster.status] || 'text-gray-600';
                    const cardHTML = `
                        <div class="bg-sky-50 p-4 rounded-lg shadow-sm border border-sky-100 flex flex-col">
                            <h4 class="font-bold text-sky-700 text-lg mb-2">${cluster.id}</h4>
                            <p class="text-sm text-gray-600">Lat/Lon: ${cluster.lat}° / ${cluster.lon}°</p>
                            <p class="text-sm text-gray-600">Area: ${parseInt(cluster.size).toLocaleString()} km²</p>
                            <p class="text-sm text-gray-600">Min Temp: ${cluster.minTemp} K</p>
                            <p class="text-sm font-semibold ${statusColor}">Status: ${cluster.status}</p>
                            <div id="forecast-output-${cluster.id}" class="mt-4 p-3 bg-white rounded-lg text-gray-700 text-sm italic hidden flex-grow"></div>
                            <button data-cluster-id="${cluster.id}" class="ai-forecast-btn mt-4 w-full bg-orange-500 hover:bg-orange-600 text-white font-bold py-2 px-4 rounded-full text-sm shadow-md transition-transform transform hover:scale-105">
                                ✨ AI TCC Forecast
                            </button>
                        </div>`;
                    clusterListDiv.insertAdjacentHTML('beforeend', cardHTML);
                });

                document.querySelectorAll('.ai-forecast-btn').forEach(button => {
                    button.addEventListener('click', async (event) => {
                        const btn = event.currentTarget;
                        const clusterId = btn.dataset.clusterId;
                        const cluster = clusters.find(c => c.id === clusterId);
                        const forecastOutputElem = document.getElementById(`forecast-output-${clusterId}`);
                        
                        btn.disabled = true;
                        btn.innerHTML = 'Generating...';
                        
                        const climateParams = {
                            sst: parseFloat(sstSlider.value),
                            windShear: parseFloat(windShearSlider.value),
                            humidity: parseFloat(humiditySlider.value)
                        };
                        
                        const forecastText = await getTccForecast(cluster, climateParams);
                        forecastOutputElem.textContent = forecastText;
                        forecastOutputElem.classList.remove('hidden');
                        
                        btn.disabled = false;
                        btn.innerHTML = '✨ AI TCC Forecast';
                    });
                });
            }

            // Other chart rendering and UI update functions...
            let tempProfileChartInstance;
            function renderTempProfileChart() {
                const ctx = document.getElementById('tempProfileChart').getContext('2d');
                if (tempProfileChartInstance) tempProfileChartInstance.destroy();
                const altitudes = [0, 2, 4, 6, 8, 10, 12, 14, 16];
                const temperatures = [295, 280, 265, 250, 235, 220, 210, 200, 195].map(t => t - 5 + Math.random() * 10);
                tempProfileChartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: altitudes,
                        datasets: [{
                            label: 'Temperature (Kelvin)',
                            data: temperatures,
                            borderColor: '#0ea5e9',
                            backgroundColor: 'rgba(14, 165, 233, 0.2)',
                            fill: true,
                            tension: 0.3
                        }]
                    },
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        scales: {
                            y: { title: { display: true, text: 'Temperature (K)' } },
                            x: { title: { display: true, text: 'Altitude (km)' } }
                        }
                    }
                });
            }

            const sstSlider = document.getElementById('sst-slider');
            const windShearSlider = document.getElementById('wind-shear-slider');
            const humiditySlider = document.getElementById('humidity-slider');
            [sstSlider, windShearSlider, humiditySlider].forEach(slider => slider.addEventListener('input', updateTCCLikelihood));
            
            function updateTCCLikelihood() {
                document.getElementById('sst-value').textContent = parseFloat(sstSlider.value).toFixed(1);
                document.getElementById('wind-shear-value').textContent = parseFloat(windShearSlider.value).toFixed(1);
                document.getElementById('humidity-value').textContent = parseFloat(humiditySlider.value).toFixed(0);
                // ... likelihood logic
            }
            
            let trainingMetricsChartInstance, currentEpoch = 0;
            function renderTrainingMetricsChart() {
                const ctx = document.getElementById('trainingMetricsChart').getContext('2d');
                if (trainingMetricsChartInstance) trainingMetricsChartInstance.destroy();
                currentEpoch++;
                const epochs = Array.from({ length: currentEpoch }, (_, i) => i + 1);
                const accuracy = epochs.map(e => Math.min(98, 70 + e * 2 + Math.random() * 5));
                const loss = epochs.map(e => Math.max(0.1, 5 - e * 0.3 - Math.random() * 0.5));
                trainingMetricsChartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: epochs.map(e => `Epoch ${e}`),
                        datasets: [
                            { label: 'Accuracy (%)', data: accuracy, borderColor: '#10b981', yAxisID: 'y' },
                            { label: 'Loss', data: loss, borderColor: '#ef4444', yAxisID: 'y1' }
                        ]
                    },
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        scales: {
                            y: { type: 'linear', position: 'left', min: 0, max: 100, title: { display: true, text: 'Accuracy (%)' } },
                            y1: { type: 'linear', position: 'right', min: 0, title: { display: true, text: 'Loss' }, grid: { drawOnChartArea: false } }
                        }
                    }
                });
            }

            // --- Main Update Function ---
            async function updateAllData() {
                showLoading("Updating analysis data...");
                updateGlobeTexture();
                updateTCCDashboardData();
                const simulatedClusters = generateSimulatedClusters(Math.floor(Math.random() * 5) + 3, currentSatellite);
                renderClusterDetails(simulatedClusters);
                currentAnalysisData.clusters = simulatedClusters;
                lastUpdatedSpan.textContent = new Date().toLocaleTimeString();
                if (window.isAuthReady) await saveClustersToFirestore(simulatedClusters);
                hideLoading();
            }

            // --- Final Initialization Call ---
            initGlobe();
        });
    </script>
</body>
</html>
