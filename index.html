<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive TCC Algorithm Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Firebase SDKs -->
    <script type="module">
        // Corrected Firebase SDK imports to only include top-level initialization functions
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global Firebase variables accessible in the main script
        window.firebaseApp = null;
        window.db = null;
        window.auth = null;
        window.userId = null;
        window.isAuthReady = false;

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-tcc-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Initialize Firebase
        if (Object.keys(firebaseConfig).length > 0) {
            window.firebaseApp = initializeApp(firebaseConfig);
            window.db = getFirestore(window.firebaseApp);
            window.auth = getAuth(window.firebaseApp);

            onAuthStateChanged(window.auth, async (user) => {
                if (user) {
                    window.userId = user.uid;
                    console.log("Firebase: User signed in:", window.userId);
                } else {
                    console.log("Firebase: No user signed in. Attempting anonymous sign-in.");
                    try {
                        if (initialAuthToken) {
                            await signInWithCustomToken(window.auth, initialAuthToken);
                        } else {
                            await signInAnonymously(window.auth);
                        }
                        window.userId = window.auth.currentUser?.uid || crypto.randomUUID(); // Fallback if anonymous fails or no uid
                        console.log("Firebase: Anonymous sign-in successful or user ID set:", window.userId);
                    } catch (error) {
                        console.error("Firebase: Anonymous sign-in failed:", error);
                        window.userId = crypto.randomUUID(); // Ensure a userId even if auth fails
                    }
                }
                window.isAuthReady = true;
                document.dispatchEvent(new CustomEvent('firebaseAuthReady')); // Notify main script
            });
        } else {
            console.warn("Firebase config not found. Running without Firestore persistence.");
            window.userId = crypto.randomUUID(); // Generate a random ID for local operation
            window.isAuthReady = true;
            document.dispatchEvent(new CustomEvent('firebaseAuthReady')); // Notify main script
        }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- 
        Chosen Palette: Calm Harmony (Light sky-blue background, deep blue/teal for text and primary elements, with muted orange accents).
        Application Structure Plan: The SPA is designed as an interactive journey through the technical report. Instead of a linear document, it uses a multi-section, dashboard-like layout. The core is the 'Interactive Methodology' section, which transforms the 6-step process into a clickable, visual flowchart. This encourages user engagement and makes the complex algorithm digestible. The 'Expected Outcomes' are presented as a tangible dashboard with dynamic charts, making abstract data points understandable at a glance. A 'Global TCC View' section introduces an interactive 3D globe to visualize simulated cloud cluster data, which auto-updates. A new 'Algorithm Q&A' section allows users to ask natural language questions about the algorithm, answered by an LLM. Navigation is non-linear via a sticky header, allowing users to explore sections based on interest rather than report order. This structure prioritizes user understanding and exploration over strict adherence to the source document's layout.
        Visualization & Content Choices: 
        - Report Info: Step-by-step algorithm. Goal: Organize/Explain. Viz: Interactive HTML/CSS flowchart. Interaction: Click to reveal details. Justification: Breaks down complexity, encourages active learning. Library/Method: Vanilla JS + Tailwind.
        - Report Info: Table 1 (Tracking Radii). Goal: Compare/Change. Viz: Bar Chart. Interaction: Hover for tooltips. Justification: Instantly visualizes the relationship between time and distance, which is clearer than a table. Library/Method: Chart.js.
        - Report Info: Expected Outcomes list. Goal: Inform/Synthesize. Viz: Data cards and a Radar Chart. Interaction: Hover on chart. Justification: Presents individual stats clearly while the radar chart gives a holistic 'fingerprint' of a sample TCC, making the list of variables tangible. Library/Method: Chart.js + Tailwind.
        - Report Info: Global TCC View. Goal: Visualize spatial data, show dynamism. Viz: 3D interactive globe with simulated satellite textures (Visible, Infrared, Water Vapor, Cloud Clusters modes), reset button, compass, real-time lat/lon display, and a color legend. Interaction: Mouse drag to rotate, auto-update, reset button click, mode selection, zoom. Justification: Provides a compelling visual representation of TCCs on a global scale, enhancing the sense of real-world application. The auto-update simulates live data, and new controls improve user interaction and orientation, while the legend clarifies the visual elements. Multiple modes offer diverse data perspectives. Zoom enhances detail. Library/Method: Three.js + Vanilla JS + Tailwind.
        - Report Info: Algorithm Q&A. Goal: Inform/Clarify. Viz: Text input/output. Interaction: User types question, clicks button, LLM provides answer. Justification: Directly addresses user queries about complex concepts in the report, providing on-demand explanations. Library/Method: Gemini API (gemini-2.0-flash) via Vanilla JS fetch.
        - Report Info: Identified Clusters Dashboard. Goal: Present detailed TCC data and model performance. Viz: Tabbed interface with dynamic lists, charts (Temperature Profile, Training Metrics), and interactive elements (Climate Parameter Explorer). Interaction: Tab switching, data display, slider manipulation. Justification: Provides a structured way to explore various aspects of identified TCCs and the underlying model's behavior. Library/Method: Chart.js + Vanilla JS + Tailwind.
        - Report Info: Evaluation Parameters. Goal: Inform. Viz: Styled content cards. Interaction: None. Justification: Cleanly separates and highlights the key metrics for success. Library/Method: Tailwind.
        CONFIRMATION: NO SVG graphics used. NO Mermaid JS used.
    -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f9ff; /* sky-50 */
            color: #075985; /* sky-800 */
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            height: 300px;
            max-height: 400px;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 350px;
            }
        }
        .step-card.active {
            border-color: #fb923c; /* orange-400 */
            transform: translateY(-5px);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        #globeCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .globe-container {
            position: relative;
            width: 100%;
            max-width: 800px; /* Max width for the globe */
            height: 500px; /* Fixed height for the globe view */
            margin-left: auto;
            margin-right: auto;
            background-color: #e0f2fe; /* blue-50 */
            border-radius: 1rem;
            overflow: hidden; /* Ensure canvas doesn't overflow */
        }
        .globe-controls {
            position: absolute;
            top: 1rem;
            left: 1rem;
            right: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none; /* Allow mouse events to pass through to canvas */
        }
        .globe-controls > * {
            pointer-events: auto; /* Re-enable pointer events for actual controls */
        }
        .compass {
            font-size: 1.5rem;
            font-weight: bold;
            color: #ef4444; /* red-500 */
            background-color: rgba(255, 255, 255, 0.7);
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .color-box {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            display: inline-block;
            vertical-align: middle;
            margin-right: 8px;
            border: 1px solid rgba(0,0,0,0.1);
        }
        /* Toggle Switch Styling */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #2196F3;
        }
        input:checked + .slider:before {
            transform: translateX(26px);
        }
        .toggle-text {
            position: absolute;
            transform: translate(-50%, -50%);
            top: 50%;
            left: 50%;
            font-size: 0.75rem;
            font-weight: bold;
            color: white;
            pointer-events: none;
            z-index: 1;
        }
        .toggle-text.left {
            left: 25%;
            color: #333; /* Darker for unchecked state */
        }
        .toggle-text.right {
            left: 75%;
            color: white; /* Lighter for checked state */
        }
        input:checked + .slider .toggle-text.left {
            color: white;
        }
        input:checked + .slider .toggle-text.right {
            color: #333;
        }
        /* Spinner for LLM Q&A */
        .llm-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #3b82f6; /* Tailwind blue-500 */
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Tabs styling */
        .tab-button.active {
            border-bottom: 3px solid #fb923c; /* orange-400 */
            color: #fb923c;
        }
        /* Loading overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(240, 249, 255, 0.8); /* sky-50 with transparency */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: #075985;
            font-weight: bold;
        }
        .loading-spinner {
            border: 8px solid rgba(7, 89, 133, 0.1);
            border-top: 8px solid #0ea5e9; /* blue-500 */
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1.5s linear infinite;
            margin-bottom: 16px;
        }
        /* Custom modal for confirm() replacement */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .modal-content {
            background-color: #fff;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
    </style>
</head>
<body class="antialiased">

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay hidden">
        <div class="loading-spinner"></div>
        <p>Loading data...</p>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirmationModal" class="modal-overlay hidden">
        <div class="modal-content">
            <p id="modalMessage" class="text-xl font-semibold text-gray-800 mb-6">Are you sure you want to clear all historical data?</p>
            <div class="flex justify-center gap-4">
                <button id="modalConfirmBtn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-full transition-transform transform hover:scale-105">Yes, Clear</button>
                <button id="modalCancelBtn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-6 rounded-full transition-transform transform hover:scale-105">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Header -->
    <header class="bg-white/80 backdrop-blur-sm sticky top-0 z-50 shadow-md">
        <nav class="container mx-auto px-6 py-3 flex justify-between items-center">
            <div class="text-2xl font-bold text-sky-700">üõ∞Ô∏è TCC Explorer</div>
            <div class="hidden md:flex space-x-6">
                <a href="#overview" class="text-gray-600 hover:text-sky-600 transition">Overview</a>
                <a href="#methodology" class="text-600 hover:text-sky-600 transition">Methodology</a>
                <a href="#globe-view" class="text-gray-600 hover:text-sky-600 transition">Global TCC View</a>
                <a href="#cluster-dashboard" class="text-gray-600 hover:text-sky-600 transition">Cluster Dashboard</a>
                <a href="#outcomes" class="text-gray-600 hover:text-sky-600 transition">Outcomes</a>
                <a href="#llm-qa" class="text-gray-600 hover:text-sky-600 transition">AI Q&A</a>
                <a href="#evaluation" class="text-gray-600 hover:text-sky-600 transition">Evaluation</a>
            </div>
            <div class="md:hidden">
                <select id="mobile-nav" class="bg-white border border-gray-300 rounded-md p-2 text-gray-700">
                    <option value="#overview">Overview</option>
                    <option value="#methodology">Methodology</option>
                    <option value="#globe-view">Global TCC View</option>
                    <option value="#cluster-dashboard">Cluster Dashboard</option>
                    <option value="#outcomes">Outcomes</option>
                    <option value="#llm-qa">AI Q&A</option>
                    <option value="#evaluation">Evaluation</option>
                </select>
            </div>
        </nav>
    </header>

    <!-- Main Content -->
    <main class="container mx-auto px-6 py-12">

        <!-- Section: Overview -->
        <section id="overview" class="text-center mb-20">
            <h1 class="text-4xl md:text-5xl font-extrabold text-sky-800 mb-4">AI-Powered Tropical Cloud Cluster Identification</h1>
            <p class="max-w-3xl mx-auto text-lg text-sky-700">
                An interactive exploration of the AI/ML algorithm designed to detect, characterize, and track Tropical Cloud Clusters (TCCs) from INSAT-3D satellite data, a critical task for weather and climate system analysis.
            </p>
        </section>

        <!-- Section: Interactive Methodology -->
        <section id="methodology" class="mb-20">
            <h2 class="text-3xl font-bold text-center mb-2 text-sky-800">The Algorithm Unpacked</h2>
            <p class="text-center text-lg text-sky-700 mb-10">This is a step-by-step interactive guide to the TCC identification process. Click on each step to see the details.</p>
            
            <div class="flex flex-col md:flex-row flex-wrap justify-center items-start gap-4">
                <!-- Step Navigation -->
                <div class="w-full md:w-1/3 grid grid-cols-2 md:grid-cols-1 gap-4">
                    <div id="step-btn-1" class="step-card active cursor-pointer border-2 border-transparent bg-white p-4 rounded-lg shadow-lg hover:shadow-xl transition-all duration-300">
                        <h3 class="font-bold text-sky-600">1. Data Ingestion</h3>
                        <p class="text-sm text-gray-500">Loading satellite data.</p>
                    </div>
                    <div id="step-btn-2" class="step-card cursor-pointer border-2 border-transparent bg-white p-4 rounded-lg shadow-lg hover:shadow-xl transition-all duration-300">
                        <h3 class="font-bold text-sky-600">2. Candidate ID</h3>
                        <p class="text-sm text-gray-500">Filtering by size & intensity.</p>
                    </div>
                    <div id="step-btn-3" class="step-card cursor-pointer border-2 border-transparent bg-white p-4 rounded-lg shadow-lg hover:shadow-xl transition-all duration-300">
                        <h3 class="font-bold text-sky-600">3. Independence</h3>
                        <p class="text-sm text-gray-500">Grouping parent clusters.</p>
                    </div>
                    <div id="step-btn-4" class="step-card cursor-pointer border-2 border-transparent bg-white p-4 rounded-lg shadow-lg hover:shadow-xl transition-all duration-300">
                        <h3 class="font-bold text-sky-600">4. Tracking</h3>
                        <p class="text-sm text-gray-500">Following TCC movement.</p>
                    </div>
                </div>

                <!-- Step Details -->
                <div class="w-full md:w-1/2 bg-white p-8 rounded-lg shadow-2xl">
                    <div id="step-content">
                        <!-- JS will populate this -->
                    </div>
                </div>
            </div>
        </section>

        <!-- Section: Global TCC View -->
        <section id="globe-view" class="mb-20">
            <h2 class="text-3xl font-bold text-center mb-2 text-sky-800">Global TCC View</h2>
            <p class="text-center text-lg text-sky-700 mb-6">Explore the simulated Tropical Cloud Clusters on an interactive globe. Data updates automatically.</p>
            <div class="globe-container shadow-2xl border border-blue-200">
                <canvas id="globeCanvas"></canvas>
                <div class="globe-controls">
                    <div class="compass">N</div>
                    <button id="resetGlobeBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-full shadow-md transition-transform transform hover:scale-105">
                        Reset View
                    </button>
                </div>
            </div>
            <div class="flex flex-col md:flex-row justify-center items-center gap-4 mt-4">
                <div class="text-center text-lg text-sky-700">
                    <p>Latitude: <span id="current-latitude">0.00</span>¬∞</p>
                    <p>Longitude: <span id="current-longitude">0.00</span>¬∞</p>
                </div>
                <div class="flex flex-wrap justify-center gap-2">
                    <button data-mode="visible" class="globe-mode-btn bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-full text-sm transition">Visible</button>
                    <button data-mode="infrared" class="globe-mode-btn bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-2 px-4 rounded-full text-sm transition">Infrared</button>
                    <button data-mode="water-vapor" class="globe-mode-btn bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-2 px-4 rounded-full text-sm transition">Water Vapor</button>
                    <button data-mode="cloud-clusters" class="globe-mode-btn bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-2 px-4 rounded-full text-sm transition">Cloud Clusters</button>
                </div>
            </div>
            <div class="flex flex-col md:flex-row justify-center items-center gap-4 mt-4">
                <div class="flex flex-col items-center">
                    <label for="satellite-select" class="text-sky-700 font-semibold mb-2">Select Satellite Data:</label>
                    <select id="satellite-select" class="p-2 border border-gray-300 rounded-md shadow-sm text-gray-800">
                        <option value="INSAT-3D">INSAT-3D (Simulated)</option>
                        <option value="GOES-16">GOES-16 (Simulated)</option>
                        <option value="Himawari-8">Himawari-8 (Simulated)</option>
                        <option value="Meteosat-11">Meteosat-11 (Simulated)</option>
                    </select>
                </div>
                <button id="downloadAnalysisBtn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-full shadow-md transition-transform transform hover:scale-105">
                    Download Analysis
                </button>
            </div>
            <div class="flex justify-center mt-4">
                <button id="clearDataBtn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-full shadow-md transition-transform transform hover:scale-105">
                    Clear Historical Data
                </button>
            </div>
            <p class="text-center text-sm text-gray-500 mt-2">Last Updated: <span id="last-updated"></span></p>

            <!-- Color Identifier Legend -->
            <div class="mt-8 p-4 bg-white rounded-lg shadow-md max-w-md mx-auto text-left">
                <h3 class="text-xl font-bold text-sky-700 mb-3 text-center">Map Legend</h3>
                <div class="flex items-center mb-2">
                    <span class="color-box bg-[#1e90ff]"></span>
                    <span class="text-gray-700">Oceans (Deep Blue to Royal Blue)</span>
                </div>
                <div class="flex items-center mb-2">
                    <span class="color-box" style="background-color: #228B22;"></span>
                    <span class="text-gray-700">Major Landmasses (Various Greens & Browns)</span>
                </div>
                <div class="flex items-center">
                    <span class="color-box bg-white border border-gray-300"></span>
                    <span class="text-gray-700">Tropical Cloud Clusters (White/Light Blue)</span>
                </div>
            </div>
        </section>

        <!-- Section: Identified Clusters Dashboard -->
        <section id="cluster-dashboard" class="mb-20">
            <h2 class="text-3xl font-bold text-center mb-2 text-sky-800">Identified Clusters Dashboard</h2>
            <p class="text-center text-lg text-sky-700 mb-10">Dive deeper into the characteristics and performance metrics of the identified TCCs.</p>
            
            <div class="bg-white/60 p-6 rounded-xl shadow-lg border border-gray-200">
                <!-- Tabs for Dashboard -->
                <div class="flex justify-center border-b border-gray-300 mb-6">
                    <button data-tab="details" class="tab-button active py-3 px-6 text-lg font-semibold text-gray-600 hover:text-sky-600 transition">Cluster Details</button>
                    <button data-tab="temp-profile" class="tab-button py-3 px-6 text-lg font-semibold text-gray-600 hover:text-sky-600 transition">Temperature Profile</button>
                    <button data-tab="climate-explorer" class="tab-button py-3 px-6 text-lg font-semibold text-gray-600 hover:text-sky-600 transition">Climate Explorer</button>
                    <button data-tab="training-metrics" class="tab-button py-3 px-6 text-lg font-semibold text-gray-600 hover:text-sky-600 transition">Training Metrics</button>
                </div>

                <!-- Tab Content -->
                <div id="tab-content-details" class="tab-content">
                    <h3 class="text-2xl font-bold text-sky-700 mb-4">Recent TCC Detections</h3>
                    <div id="cluster-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        <!-- Cluster cards will be dynamically inserted here -->
                    </div>
                </div>

                <div id="tab-content-temp-profile" class="tab-content hidden">
                    <h3 class="text-2xl font-bold text-sky-700 mb-4">Typical TCC Temperature Profile</h3>
                    <p class="text-gray-700 mb-4">This chart shows a simulated vertical temperature profile within a mature Tropical Cloud Cluster.</p>
                    <div class="chart-container">
                        <canvas id="tempProfileChart"></canvas>
                    </div>
                </div>

                <div id="tab-content-climate-explorer" class="tab-content hidden">
                    <h3 class="text-2xl font-bold text-sky-700 mb-4">Climate Parameter Impact Explorer</h3>
                    <p class="text-gray-700 mb-4">Adjust the sliders to see the simulated impact of various climate parameters on TCC activity.</p>
                    <div class="p-4 bg-blue-50 rounded-lg shadow-inner">
                        <div class="mb-4">
                            <label for="sst-slider" class="block text-sky-700 font-semibold mb-2">Sea Surface Temperature (¬∞C): <span id="sst-value">28</span></label>
                            <input type="range" id="sst-slider" min="25" max="32" value="28" step="0.1" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer">
                        </div>
                        <div class="mb-4">
                            <label for="wind-shear-slider" class="block text-sky-700 font-semibold mb-2">Vertical Wind Shear (m/s): <span id="wind-shear-value">10</span></label>
                            <input type="range" id="wind-shear-slider" min="5" max="20" value="10" step="0.5" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer">
                        </div>
                        <div class="mb-4">
                            <label for="humidity-slider" class="block text-sky-700 font-semibold mb-2">Mid-Level Humidity (%): <span id="humidity-value">70</span></label>
                            <input type="range" id="humidity-slider" min="50" max="90" value="70" step="1" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer">
                        </div>
                        <p class="text-center text-lg font-bold mt-6">Simulated TCC Activity Likelihood: <span id="tcc-likelihood" class="text-sky-800">Moderate</span></p>
                    </div>
                </div>

                <div id="tab-content-training-metrics" class="tab-content hidden">
                    <h3 class="text-2xl font-bold text-sky-700 mb-4">AI Model Training Metrics</h3>
                    <p class="text-gray-700 mb-4">Visualizing the performance of the TCC identification model during training.</p>
                    <div class="chart-container">
                        <canvas id="trainingMetricsChart"></canvas>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section: Expected Outcomes -->
        <section id="outcomes" class="mb-20">
            <h2 class="text-3xl font-bold text-center mb-2 text-sky-800">Expected Outcomes Dashboard</h2>
            <p class="text-center text-lg text-sky-700 mb-10">The algorithm generates a rich set of variables for each TCC. Here‚Äôs a sample visualization of a single identified cluster, updated periodically.</p>
            
            <div class="bg-white/60 p-6 rounded-xl shadow-lg border border-gray-200">
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8 text-center" id="outcome-cards">
                    <div class="bg-sky-50 p-4 rounded-lg">
                        <p class="text-sm text-sky-600">Mean Temp (Tb)</p>
                        <p class="text-2xl font-bold text-sky-800" id="mean-temp">225.4 K</p>
                        <label class="toggle-switch mt-2">
                            <input type="checkbox" id="tempUnitToggle">
                            <span class="slider">
                                <span class="toggle-text left">K</span>
                                <span class="toggle-text right">¬∞C</span>
                            </span>
                        </label>
                    </div>
                    <div class="bg-sky-50 p-4 rounded-lg">
                        <p class="text-sm text-sky-600">Min Temp (Tb)</p>
                        <p class="text-2xl font-bold text-sky-800" id="min-temp">198.1 K</p>
                    </div>
                    <div class="bg-sky-50 p-4 rounded-lg">
                        <p class="text-sm text-sky-600">Mean Radius</p>
                        <p class="text-2xl font-bold text-sky-800" id="mean-radius">152 km</p>
                    </div>
                    <div class="bg-sky-50 p-4 rounded-lg">
                        <p class="text-sm text-sky-600">Mean Cld Height</p>
                        <p class="text-2xl font-bold text-sky-800" id="mean-cloud-height">14.2 km</p>
                    </div>
                </div>

                <!-- Area Stats Checker -->
                <div class="mt-8 p-6 bg-blue-50 rounded-lg shadow-md border border-blue-200">
                    <h3 class="text-xl font-bold text-sky-700 mb-4 text-center">TCC Area Checker</h3>
                    <p class="text-gray-700 mb-4 text-center">Enter an area (in km¬≤) to check if it meets the minimum TCC size requirement (34,800 km¬≤).</p>
                    <div class="flex flex-col md:flex-row items-center justify-center gap-4">
                        <input
                            type="number"
                            id="areaInput"
                            placeholder="e.g., 40000"
                            class="flex-grow p-3 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-800 max-w-xs w-full"
                        >
                        <button
                            id="checkAreaBtn"
                            class="bg-orange-500 hover:bg-orange-600 text-white font-bold py-3 px-8 rounded-full shadow-lg transition-transform transform hover:scale-105 duration-300"
                        >
                            Check Area
                        </button>
                    </div>
                    <p id="areaCheckResult" class="text-center mt-4 font-medium text-gray-800"></p>
                </div>

                <div class="chart-container mt-8">
                    <canvas id="outcomesRadarChart"></canvas>
                </div>
            </div>
        </section>

        <!-- Section: LLM Q&A -->
        <section id="llm-qa" class="mb-20">
            <h2 class="text-3xl font-bold text-center mb-2 text-sky-800">‚ú® Algorithm Q&A ‚ú®</h2>
            <p class="text-center text-lg text-sky-700 mb-6">Ask our AI assistant any question about the TCC identification algorithm or related concepts.</p>
            <div class="bg-white/60 p-6 rounded-xl shadow-lg border border-blue-200 max-w-2xl mx-auto">
                <textarea
                    id="qaInput"
                    class="w-full p-3 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-sky-500 text-gray-800 mb-4"
                    rows="4"
                    placeholder="e.g., What is IRBRT data? How is TCC independence determined?"
                ></textarea>
                <button
                    id="askAiBtn"
                    class="bg-sky-600 hover:bg-sky-700 text-white font-bold py-3 px-8 rounded-full shadow-lg transition-transform transform hover:scale-105 duration-300 flex items-center justify-center mx-auto"
                >
                    Ask AI
                </button>
                <div id="qaLoadingSpinner" class="hidden flex justify-center items-center py-4 mt-4">
                    <div class="llm-spinner"></div>
                    <span class="ml-3 text-sky-600 font-medium">AI is thinking...</span>
                </div>
                <div
                    id="qaOutput"
                    class="bg-white p-4 rounded-lg shadow-inner border border-gray-200 min-h-[100px] text-gray-700 mt-6 whitespace-pre-wrap"
                >
                    Your AI answers will appear here.
                </div>
            </div>
        </section>

        <!-- Section: Evaluation -->
        <section id="evaluation">
            <h2 class="text-3xl font-bold text-center mb-10 text-sky-800">Evaluation Criteria</h2>
            <div class="grid md:grid-cols-3 gap-8">
                <div class="bg-white p-6 rounded-lg shadow-md border border-gray-200">
                    <h3 class="text-2xl font-bold text-sky-700 mb-3">üéØ Accuracy</h3>
                    <p class="text-gray-600">Precision of the retrieved data against ground truth. Evaluates correctness of TCC identification, characterization, and tracking.</p>
                </div>
                <div class="bg-white p-6 rounded-lg shadow-md border border-gray-200">
                    <h3 class="text-2xl font-bold text-sky-700 mb-3">‚úÖ Relevance</h3>
                    <p class="text-gray-600">The degree to which identified TCCs align with meteorological definitions and their utility for forecasting and research.</p>
                </div>
                <div class="bg-white p-6 rounded-lg shadow-md border border-gray-200">
                    <h3 class="text-2xl font-bold text-sky-700 mb-3">üßë‚Äçüíª User Experience</h3>
                    <p class="text-gray-600">The ease of use, speed, and overall satisfaction for researchers and forecasters using the generated ITCC dataset.</p>
                </div>
            </div>
        </section>

    </main>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const loadingOverlay = document.getElementById('loadingOverlay');
            const confirmationModal = document.getElementById('confirmationModal');
            const modalMessage = document.getElementById('modalMessage');
            const modalConfirmBtn = document.getElementById('modalConfirmBtn');
            const modalCancelBtn = document.getElementById('modalCancelBtn');

            // Show loading overlay
            function showLoading(message = "Loading data...") {
                loadingOverlay.querySelector('p').textContent = message;
                loadingOverlay.classList.remove('hidden');
            }

            // Hide loading overlay
            function hideLoading() {
                loadingOverlay.classList.add('hidden');
            }

            // Show confirmation modal
            function showConfirmationModal(message, onConfirm) {
                modalMessage.textContent = message;
                confirmationModal.classList.remove('hidden');
                return new Promise((resolve) => {
                    const confirmHandler = () => {
                        modalConfirmBtn.removeEventListener('click', confirmHandler);
                        modalCancelBtn.removeEventListener('click', cancelHandler);
                        confirmationModal.classList.add('hidden');
                        resolve(true);
                    };
                    const cancelHandler = () => {
                        modalConfirmBtn.removeEventListener('click', confirmHandler);
                        modalCancelBtn.removeEventListener('click', cancelHandler);
                        confirmationModal.classList.add('hidden');
                        resolve(false);
                    };
                    modalConfirmBtn.addEventListener('click', confirmHandler);
                    modalCancelBtn.addEventListener('click', cancelHandler);
                });
            }

            // Wait for Firebase Auth to be ready before proceeding
            document.addEventListener('firebaseAuthReady', async () => {
                console.log("Firebase Auth is ready. User ID:", window.userId);
                await loadHistoricalClusters(); // Load historical data first
                updateAllData(); // Then perform initial data update
                setInterval(updateAllData, 1800000); // Update every 30 minutes (1800000 ms)
                hideLoading(); // Hide loading after initial data is loaded
            });

            // Show loading immediately on DOMContentLoaded
            showLoading("Initializing application...");

            // --- Section Navigation Logic ---
            const mobileNav = document.getElementById('mobile-nav');
            mobileNav.addEventListener('change', (e) => {
                window.location.href = e.target.value;
            });

            // --- Interactive Methodology Section Logic ---
            const stepContent = document.getElementById('step-content');
            const stepButtons = [
                document.getElementById('step-btn-1'),
                document.getElementById('step-btn-2'),
                document.getElementById('step-btn-3'),
                document.getElementById('step-btn-4')
            ];

            const stepsData = {
                '1': {
                    title: 'Step 1: Data Preprocessing and Ingestion',
                    content: `
                        <p class="mb-4 text-gray-700">The process begins by loading half-hourly INSAT-3D Infrared Brightness Temperature (IRBRT) data. Each satellite image must be properly georeferenced to map pixel coordinates to their real-world latitude and longitude.</p>
                        <ul class="list-disc list-inside text-gray-600 space-y-2">
                            <li><strong>Source:</strong> INSAT-3D Satellite</li>
                            <li><strong>Data Type:</strong> Infrared Brightness Temperature (IRBRT)</li>
                            <li><strong>Frequency:</strong> Half-hourly</li>
                            <li><strong>Key Action:</strong> Georeferencing & Normalization</li>
                        </ul>`
                },
                '2': {
                    title: 'Step 2: TCC Candidate Identification',
                    content: `
                        <p class="mb-4 text-gray-700">TCC candidates are first identified by their temperature and size. A scene is filtered using a pre-determined IRBT threshold. Contiguous pixels that pass this filter are then evaluated based on size criteria.</p>
                        <ul class="list-disc list-inside text-gray-600 space-y-2">
                            <li><strong>IRBT Threshold:</strong> Only pixels below a certain temperature pass.</li>
                            <li><strong>Minimum Radius:</strong> Must be at least <strong>1¬∞ (~111 km)</strong> in one direction.</li>
                            <li><strong>Minimum Area:</strong> Must cover at least <strong>34,800 km¬≤</strong>.</li>
                        </ul>`
                },
                '3': {
                    title: 'Step 3: Independence Determination',
                    content: `
                        <p class="mb-4 text-gray-700">TCCs can be complex systems. If multiple convective areas are close, the algorithm determines if they are independent or part of a larger 'parent' system.</p>
                        <ul class="list-disc list-inside text-gray-600 space-y-2">
                            <li><strong>Proximity Rule:</strong> Candidates within <strong>1200 km</strong> of a larger 'parent' cluster are considered subsets of it.</li>
                            <li><strong>Distinct TCC:</strong> If a candidate is more than <strong>1200 km</strong> away, it is classified as a distinct system.</li>
                        </ul>`
                },
                '4': {
                    title: 'Step 4: TCC Tracking',
                    content: `
                        <p class="mb-4 text-gray-700">Once a TCC is confirmed, the algorithm tracks its movement by searching back in time and matching it with previous records based on proximity.</p>
                        <div class="chart-container !h-[250px] md:!h-[300px] mt-4">
                            <canvas id="trackingChart"></canvas>
                        </div>`
                },
            };
            
            function updateStepContent(step) {
                const data = stepsData[step];
                stepContent.innerHTML = `<h3 class="text-2xl font-bold text-sky-800 mb-4">${data.title}</h3>${data.content}`;

                stepButtons.forEach((btn, index) => {
                    btn.classList.toggle('active', (index + 1) == step);
                });
                
                if (step == 4) {
                    renderTrackingChart();
                }
            }
            
            stepButtons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    updateStepContent(index + 1);
                });
            });

            updateStepContent(1); // Initialize with first step

            let trackingChartInstance;
            function renderTrackingChart() {
                const ctx = document.getElementById('trackingChart').getContext('2d');
                if(trackingChartInstance) {
                    trackingChartInstance.destroy();
                }
                trackingChartInstance = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['3 hrs', '6 hrs', '9 hrs', '12 hrs'],
                        datasets: [{
                            label: 'Search Radius (km)',
                            data: [450, 550, 600, 650],
                            backgroundColor: '#38bdf8',
                            borderColor: '#0ea5e9',
                            borderWidth: 1,
                            borderRadius: 5,
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Tracking Search Radius vs. Time',
                                color: '#0c4a6e'
                            },
                            legend: {
                                display: false
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: false,
                                title: {
                                    display: true,
                                    text: 'Radius (km)',
                                    color: '#075985'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Time Since Last Location',
                                    color: '#075985'
                                }
                            }
                        }
                    }
                });
            }

            // --- Expected Outcomes Dashboard Logic (existing) ---
            let outcomesRadarChartInstance;
            const radarCtx = document.getElementById('outcomesRadarChart').getContext('2d');
            function renderOutcomesRadarChart(data) {
                if(outcomesRadarChartInstance) {
                    outcomesRadarChartInstance.destroy();
                }
                outcomesRadarChartInstance = new Chart(radarCtx, {
                    type: 'radar',
                    data: {
                        labels: ['Mean Temp', 'Min Temp', 'Max Radius', 'Mean Radius', 'Max Cloud Height', 'Mean Cloud Height'],
                        datasets: [{
                            label: 'Sample TCC Characteristics (Normalized)',
                            data: data,
                            backgroundColor: 'rgba(56, 189, 248, 0.2)',
                            borderColor: '#0ea5e9',
                            pointBackgroundColor: '#0ea5e9',
                            pointBorderColor: '#fff',
                            pointHoverBackgroundColor: '#fff',
                            pointHoverBorderColor: '#0ea5e9'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Normalized Profile of a Sample TCC',
                                color: '#0c4a6e'
                            },
                            legend: {
                                position: 'bottom'
                            }
                        },
                        scales: {
                            r: {
                                angleLines: {
                                    color: 'rgba(7, 89, 133, 0.2)'
                                },
                                grid: {
                                    color: 'rgba(7, 89, 133, 0.2)'
                                },
                                pointLabels: {
                                    font: {
                                        size: 12
                                    },
                                    color: '#075985'
                                },
                                ticks: {
                                    backdropColor: '#f0f9ff',
                                    color: '#0369a1',
                                    beginAtZero: true,
                                    min: 0,
                                    max: 1,
                                    stepSize: 0.2
                                }
                            }
                        }
                    }
                });
            }

            const meanTempElem = document.getElementById('mean-temp');
            const minTempElem = document.getElementById('min-temp');
            const meanRadiusElem = document.getElementById('mean-radius');
            const meanCloudHeightElem = document.getElementById('mean-cloud-height');
            const tempUnitToggle = document.getElementById('tempUnitToggle');
            let currentTempUnit = 'K';

            function kelvinToCelsius(kelvin) {
                return (parseFloat(kelvin) - 273.15).toFixed(1);
            }

            function updateTCCDashboardData() {
                const newMeanTempK = (220 + Math.random() * 10).toFixed(1);
                const newMinTempK = (190 + Math.random() * 10).toFixed(1);
                const newMeanRadius = (100 + Math.random() * 100).toFixed(0);
                const newMeanCloudHeight = (12 + Math.random() * 4).toFixed(1);

                meanTempElem.dataset.kelvin = newMeanTempK;
                minTempElem.dataset.kelvin = newMinTempK;

                if (currentTempUnit === 'K') {
                    meanTempElem.textContent = `${newMeanTempK} K`;
                    minTempElem.textContent = `${newMinTempK} K`;
                } else {
                    meanTempElem.textContent = `${kelvinToCelsius(newMeanTempK)} ¬∞C`;
                    minTempElem.textContent = `${kelvinToCelsius(newMinTempK)} ¬∞C`;
                }
                
                meanRadiusElem.textContent = `${newMeanRadius} km`;
                meanCloudHeightElem.textContent = `${newMeanCloudHeight} km`;

                const normalizedData = [
                    (newMeanTempK - 210) / 20,
                    (newMinTempK - 180) / 30,
                    (newMeanRadius - 50) / 200,
                    (newMeanRadius - 50) / 200,
                    (newMeanCloudHeight - 10) / 10,
                    (newMeanCloudHeight - 10) / 10
                ].map(val => Math.max(0, Math.min(1, val)));

                renderOutcomesRadarChart(normalizedData);
            }

            tempUnitToggle.addEventListener('change', () => {
                currentTempUnit = tempUnitToggle.checked ? 'C' : 'K';
                const currentMeanTempK = meanTempElem.dataset.kelvin;
                const currentMinTempK = minTempElem.dataset.kelvin;

                if (currentTempUnit === 'K') {
                    meanTempElem.textContent = `${currentMeanTempK} K`;
                    minTempElem.textContent = `${currentMinTempK} K`;
                } else {
                    meanTempElem.textContent = `${kelvinToCelsius(currentMeanTempK)} ¬∞C`;
                    minTempElem.textContent = `${kelvinToCelsius(currentMinTempK)} ¬∞C`;
                }
            });

            // Area Stats Checker Logic
            const areaInput = document.getElementById('areaInput');
            const checkAreaBtn = document.getElementById('checkAreaBtn');
            const areaCheckResult = document.getElementById('areaCheckResult');
            const MIN_TCC_AREA = 34800;

            checkAreaBtn.addEventListener('click', () => {
                const enteredArea = parseFloat(areaInput.value);

                if (isNaN(enteredArea)) {
                    areaCheckResult.textContent = "Please enter a valid number for the area.";
                    areaCheckResult.className = 'text-center mt-4 font-medium text-red-600';
                } else if (enteredArea >= MIN_TCC_AREA) {
                    areaCheckResult.textContent = `‚úÖ ${enteredArea} km¬≤ meets the minimum TCC area requirement!`;
                    areaCheckResult.className = 'text-center mt-4 font-medium text-green-600';
                } else {
                    areaCheckResult.textContent = `‚ùå ${enteredArea} km¬≤ is below the minimum TCC area of ${MIN_TCC_AREA} km¬≤.`;
                    areaCheckResult.className = 'text-center mt-4 font-medium text-red-600';
                }
            });

            // --- LLM Q&A Logic ---
            const qaInput = document.getElementById('qaInput');
            const askAiBtn = document.getElementById('askAiBtn');
            const qaOutput = document.getElementById('qaOutput');
            const qaLoadingSpinner = document.getElementById('qaLoadingSpinner');

            askAiBtn.addEventListener('click', async () => {
                const question = qaInput.value.trim();
                if (!question) {
                    qaOutput.textContent = "Please enter a question to ask the AI.";
                    qaOutput.classList.remove('text-green-600', 'text-red-600');
                    qaOutput.classList.add('text-gray-700');
                    return;
                }

                qaLoadingSpinner.classList.remove('hidden');
                qaOutput.textContent = '';
                askAiBtn.disabled = true;

                try {
                    const prompt = `Based on the provided context about the 'AI/ML Algorithm for Identifying Tropical Cloud Clusters Using Half-Hourly Satellite Data from the INSAT', answer the following question: "${question}". Focus on explaining concepts related to the algorithm's methodology, objectives, expected outcomes, and evaluation parameters. If the question is outside this scope, state that you cannot answer it based on the provided information.`;
                    
                    let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
                    const payload = { contents: chatHistory };
                    const apiKey = ""; 
                    // Updated API URL to use the latest model
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`API error: ${response.status} - ${errorData.error.message || 'Unknown error'}`);
                    }

                    const result = await response.json();
                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const text = result.candidates[0].content.parts[0].text;
                        qaOutput.textContent = text;
                        qaOutput.classList.remove('text-red-600');
                        qaOutput.classList.add('text-gray-700');
                    } else {
                        qaOutput.textContent = "Sorry, I couldn't generate an answer. Please try rephrasing your question.";
                        qaOutput.classList.remove('text-green-600');
                        qaOutput.classList.add('text-red-600');
                    }

                } catch (error) {
                    console.error("Error asking AI:", error);
                    qaOutput.textContent = `An error occurred: ${error.message}. Please try again.`;
                    qaOutput.classList.remove('text-green-600');
                    qaOutput.classList.add('text-red-600');
                } finally {
                    qaLoadingSpinner.classList.add('hidden');
                    askAiBtn.disabled = false;
                }
            });

            // --- Global TCC View Logic (enhanced) ---
            const globeContainer = document.querySelector('.globe-container');
            const globeCanvas = document.getElementById('globeCanvas');
            const lastUpdatedSpan = document.getElementById('last-updated');
            const resetGlobeBtn = document.getElementById('resetGlobeBtn');
            const currentLatitudeSpan = document.getElementById('current-latitude');
            const currentLongitudeSpan = document.getElementById('current-longitude');
            const globeModeButtons = document.querySelectorAll('.globe-mode-btn');
            const satelliteSelect = document.getElementById('satellite-select');
            const downloadAnalysisBtn = document.getElementById('downloadAnalysisBtn');
            const clearDataBtn = document.getElementById('clearDataBtn');

            let scene, camera, renderer, earthMesh;
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            let initialPinchDistance = 0;
            const rotationSpeed = 0.005;
            const zoomSpeed = 0.1;
            const minZoom = 7;
            const maxZoom = 15;
            const initialRotation = { x: 0.2, y: 0.5 }; // Slightly rotated initial view
            let currentGlobeMode = 'visible'; // Default mode
            let currentSatellite = 'INSAT-3D'; // Default satellite

            function initGlobe() {
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, globeContainer.clientWidth / globeContainer.clientHeight, 0.1, 1000);
                renderer = new THREE.WebGLRenderer({ canvas: globeCanvas, antialias: true });
                renderer.setSize(globeContainer.clientWidth, globeContainer.clientHeight);
                renderer.setClearColor(0xf0f9ff, 1);

                const geometry = new THREE.SphereGeometry(5, 64, 64);
                const material = new THREE.MeshPhongMaterial({
                    shininess: 30,
                    specular: 0x999999
                });
                earthMesh = new THREE.Mesh(geometry, material);
                scene.add(earthMesh);

                const ambientLight = new THREE.AmbientLight(0xcccccc, 0.5);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 3, 5).normalize();
                scene.add(directionalLight);

                camera.position.z = 10;
                earthMesh.rotation.x = initialRotation.x;
                earthMesh.rotation.y = initialRotation.y;

                globeCanvas.addEventListener('mousedown', onMouseDown);
                globeCanvas.addEventListener('mousemove', onMouseMove);
                globeCanvas.addEventListener('mouseup', onMouseUp);
                globeCanvas.addEventListener('mouseleave', onMouseUp);
                globeCanvas.addEventListener('wheel', onMouseWheel); // Add wheel listener

                globeCanvas.addEventListener('touchstart', onTouchStart, { passive: true });
                globeCanvas.addEventListener('touchmove', onTouchMove, { passive: true });
                globeCanvas.addEventListener('touchend', onTouchEnd, { passive: true });

                resetGlobeBtn.addEventListener('click', resetGlobeView);

                globeModeButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        currentGlobeMode = button.dataset.mode;
                        updateGlobeTexture();
                        // Highlight active button
                        globeModeButtons.forEach(btn => btn.classList.remove('bg-blue-500', 'text-white'));
                        globeModeButtons.forEach(btn => btn.classList.add('bg-gray-200', 'text-gray-800'));
                        button.classList.add('bg-blue-500', 'text-white');
                        button.classList.remove('bg-gray-200', 'text-gray-800');
                    });
                });
                // Set initial active mode button
                document.querySelector(`.globe-mode-btn[data-mode="${currentGlobeMode}"]`).classList.add('bg-blue-500', 'text-white');
                document.querySelector(`.globe-mode-btn[data-mode="${currentGlobeMode}"]`).classList.remove('bg-gray-200', 'text-gray-800');

                satelliteSelect.addEventListener('change', (e) => {
                    currentSatellite = e.target.value;
                    updateGlobeTexture(); // Update globe based on new satellite selection
                    updateAllData(); // Re-generate clusters based on new satellite
                });

                downloadAnalysisBtn.addEventListener('click', downloadRecentAnalysis);
                clearDataBtn.addEventListener('click', async () => {
                    const userConfirmed = await showConfirmationModal('Are you sure you want to clear all historical data? This cannot be undone.', null);
                    if (userConfirmed) {
                        await clearHistoricalData();
                    }
                });

                animateGlobe();
                window.addEventListener('resize', onWindowResize);
                updateLatLonDisplay(); // Initial display
            }

            function onWindowResize() {
                camera.aspect = globeContainer.clientWidth / globeContainer.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(globeContainer.clientWidth, globeContainer.clientHeight);
            }

            function onMouseWheel(event) {
                event.preventDefault(); // Prevent page scrolling
                camera.position.z -= event.deltaY * 0.01 * zoomSpeed;
                camera.position.z = Math.max(minZoom, Math.min(maxZoom, camera.position.z)); // Clamp zoom
            }

            function onMouseDown(event) {
                isDragging = true;
                previousMousePosition = { x: event.clientX, y: event.clientY };
            }

            function onMouseMove(event) {
                if (!isDragging) return;
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;

                earthMesh.rotation.y += deltaX * rotationSpeed;
                earthMesh.rotation.x += deltaY * rotationSpeed;

                previousMousePosition = { x: event.clientX, y: event.clientY };
                updateLatLonDisplay();
            }

            function onMouseUp() {
                isDragging = false;
            }

            function getPinchDistance(touches) {
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }

            function onTouchStart(event) {
                if (event.touches.length === 2) { // Pinch-to-zoom
                    initialPinchDistance = getPinchDistance(event.touches);
                } else if (event.touches.length === 1) { // Single finger drag
                    isDragging = true;
                    previousMousePosition = { x: event.touches[0].clientX, y: event.touches[0].clientY };
                }
            }

            function onTouchMove(event) {
                if (event.touches.length === 2) { // Pinch-to-zoom
                    const currentPinchDistance = getPinchDistance(event.touches);
                    const deltaPinch = currentPinchDistance - initialPinchDistance;
                    camera.position.z -= deltaPinch * 0.01 * zoomSpeed;
                    camera.position.z = Math.max(minZoom, Math.min(maxZoom, camera.position.z));
                    initialPinchDistance = currentPinchDistance; // Update initial for next move
                } else if (isDragging && event.touches.length === 1) { // Single finger drag
                    const touch = event.touches[0];
                    const deltaX = touch.clientX - previousMousePosition.x;
                    const deltaY = touch.clientY - previousMousePosition.y;

                    earthMesh.rotation.y += deltaX * rotationSpeed;
                    earthMesh.rotation.x += deltaY * rotationSpeed;

                    previousMousePosition = { x: touch.clientX, y: touch.clientY };
                    updateLatLonDisplay();
                }
            }

            function onTouchEnd() {
                isDragging = false;
                initialPinchDistance = 0;
            }

            function animateGlobe() {
                requestAnimationFrame(animateGlobe);
                renderer.render(scene, camera);
            }

            function resetGlobeView() {
                earthMesh.rotation.x = initialRotation.x;
                earthMesh.rotation.y = initialRotation.y;
                camera.position.z = 10; // Reset zoom
                updateLatLonDisplay();
            }

            function updateLatLonDisplay() {
                // Simplified conversion for display purposes
                let lat = (earthMesh.rotation.x * 180 / Math.PI) % 360;
                if (lat > 180) lat -= 360;
                if (lat < -180) lat += 360;
                if (lat > 90) lat = 180 - lat;
                if (lat < -90) lat = -180 - lat;

                let lon = (earthMesh.rotation.y * 180 / Math.PI) % 360;
                if (lon > 180) lon -= 360;
                if (lon < -180) lon += 360;

                currentLatitudeSpan.textContent = lon.toFixed(2);
                currentLongitudeSpan.textContent = lat.toFixed(2);
            }

            // --- Texture Generation Functions for Globe Modes ---
            function drawLandmasses(ctx, landColor, detail = 1) {
                ctx.fillStyle = landColor;
                const w = ctx.canvas.width;
                const h = ctx.canvas.height;

                // North America
                ctx.beginPath();
                ctx.moveTo(w * 0.08, h * 0.2);
                ctx.bezierCurveTo(w * 0.25, h * 0.05, w * 0.35, h * 0.15, w * 0.3, h * 0.35);
                ctx.bezierCurveTo(w * 0.25, h * 0.45, w * 0.15, h * 0.4, w * 0.05, h * 0.3);
                ctx.closePath();
                ctx.fill();

                // South America
                ctx.beginPath();
                ctx.moveTo(w * 0.18, h * 0.45);
                ctx.bezierCurveTo(w * 0.28, h * 0.35, w * 0.35, h * 0.55, w * 0.25, h * 0.75);
                ctx.bezierCurveTo(w * 0.15, h * 0.65, w * 0.1, h * 0.55, w * 0.18, h * 0.45);
                ctx.closePath();
                ctx.fill();

                // Africa
                ctx.beginPath();
                ctx.moveTo(w * 0.4, h * 0.3);
                ctx.bezierCurveTo(w * 0.5, h * 0.15, w * 0.6, h * 0.2, w * 0.58, h * 0.4);
                ctx.bezierCurveTo(w * 0.5, h * 0.65, w * 0.4, h * 0.7, w * 0.35, h * 0.55);
                ctx.bezierCurveTo(w * 0.38, h * 0.35, w * 0.4, h * 0.3, w * 0.4, h * 0.3);
                ctx.closePath();
                ctx.fill();

                // Europe
                ctx.beginPath();
                ctx.moveTo(w * 0.55, h * 0.1);
                ctx.bezierCurveTo(w * 0.65, h * 0.05, w * 0.7, h * 0.15, w * 0.6, h * 0.25);
                ctx.closePath();
                ctx.fill();

                // Asia
                ctx.beginPath();
                ctx.moveTo(w * 0.7, h * 0.05);
                ctx.bezierCurveTo(w * 0.95, h * 0.1, w * 0.9, h * 0.4, w * 0.75, h * 0.5);
                ctx.bezierCurveTo(w * 0.65, h * 0.4, w * 0.7, h * 0.05, w * 0.7, h * 0.05);
                ctx.closePath();
                ctx.fill();

                // India
                ctx.beginPath();
                ctx.moveTo(w * 0.72, h * 0.45);
                ctx.lineTo(w * 0.73, h * 0.55);
                ctx.lineTo(w * 0.71, h * 0.6);
                ctx.lineTo(w * 0.70, h * 0.5);
                ctx.closePath();
                ctx.fill();

                // Australia
                ctx.beginPath();
                ctx.ellipse(w * 0.8, h * 0.7, 80 * detail, 50 * detail, Math.PI / 6, 0, Math.PI * 2);
                ctx.closePath();
                ctx.fill();

                // Antarctica
                ctx.fillStyle = '#ADD8E6'; // Light Blue for ice
                ctx.beginPath();
                ctx.moveTo(0, h * 0.9);
                ctx.lineTo(w, h * 0.9);
                ctx.lineTo(w, h);
                ctx.lineTo(0, h);
                ctx.closePath();
                ctx.fill();
            }

            function drawClouds(ctx, cloudColor, density = 1, randomSeed = 0) {
                // Use a seeded random for consistent cloud patterns per update, but different per satellite/mode
                const originalRandom = Math.random;
                Math.random = createSeededRandom(randomSeed);

                ctx.globalAlpha = 0.3 * density;
                for (let i = 0; i < 80 * density; i++) {
                    const x = Math.random() * ctx.canvas.width;
                    const y = Math.random() * ctx.canvas.height;
                    const baseRadius = 30 + Math.random() * 70;
                    const numBlobs = 3 + Math.floor(Math.random() * 5);

                    ctx.fillStyle = cloudColor + (0.3 + Math.random() * 0.5) + ')';
                    ctx.beginPath();
                    for (let j = 0; j < numBlobs; j++) {
                        const offsetX = (Math.random() - 0.5) * baseRadius * 1.5;
                        const offsetY = (Math.random() - 0.5) * baseRadius * 1.5;
                        // Ensure blobRadius is always non-negative
                        const blobRadius = Math.max(0, baseRadius * (0.5 + Math.random() * 0.5)); 
                        ctx.arc(x + offsetX, y + offsetY, blobRadius, 0, Math.PI * 2);
                    }
                    ctx.fill();
                }
                ctx.globalAlpha = 1.0;
                Math.random = originalRandom; // Restore original random
            }

            // Simple seeded random number generator for consistent textures
            function createSeededRandom(seed) {
                let x = Math.sin(seed) * 10000;
                return function() {
                    x = (x * 9301 + 49297) % 233280;
                    return x / 233280;
                };
            }

            function drawGrid(ctx, lineColor = 'rgba(255,255,255,0.2)') {
                const w = ctx.canvas.width;
                const h = ctx.canvas.height;
                ctx.strokeStyle = lineColor;
                ctx.lineWidth = 1;

                // Latitude lines (every 30 degrees)
                for (let i = -60; i <= 60; i += 30) {
                    const y = h / 2 - (i / 180) * h;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }

                // Longitude lines (every 30 degrees)
                for (let i = -180; i <= 180; i += 30) {
                    const x = w / 2 + (i / 360) * w;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                }
            }


            function generateVisibleTexture(satelliteSeed) {
                const canvas = document.createElement('canvas');
                canvas.width = 2048;
                canvas.height = 1024;
                const ctx = canvas.getContext('2d');

                const oceanGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                oceanGradient.addColorStop(0, '#0a3d62'); // Deep ocean
                oceanGradient.addColorStop(0.5, '#1e90ff'); // Royal blue
                oceanGradient.addColorStop(1, '#0a3d62');
                ctx.fillStyle = oceanGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                drawLandmasses(ctx, '#228B22'); // Forest Green for land
                drawClouds(ctx, 'rgba(255, 255, 255, ', 1, satelliteSeed + 1); // White clouds, unique seed
                drawGrid(ctx); // Add grid
                return new THREE.CanvasTexture(canvas);
            }

            function generateInfraredTexture(satelliteSeed) {
                const canvas = document.createElement('canvas');
                canvas.width = 2048;
                canvas.height = 1024;
                const ctx = canvas.getContext('2d');

                // Simulate IR: Colder (higher clouds) are brighter, warmer (surface) are darker
                const irGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                irGradient.addColorStop(0, '#333333'); // Dark for warm oceans/low land
                irGradient.addColorStop(0.5, '#888888'); // Mid-range
                irGradient.addColorStop(1, '#333333');
                ctx.fillStyle = irGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                drawLandmasses(ctx, '#555555'); // Darker grey for land
                drawClouds(ctx, 'rgba(255, 255, 255, ', 1.5, satelliteSeed + 2); // Very bright white clouds for cold tops, unique seed
                drawGrid(ctx, 'rgba(200,200,200,0.3)'); // Add grid
                return new THREE.CanvasTexture(canvas);
            }

            function generateWaterVaporTexture(satelliteSeed) {
                const canvas = document.createElement('canvas');
                canvas.width = 2048;
                canvas.height = 1024;
                const ctx = canvas.getContext('2d');

                const wvGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                wvGradient.addColorStop(0, '#003366'); // Dark blue for dry
                wvGradient.addColorStop(0.5, '#6699CC'); // Light blue for moist
                wvGradient.addColorStop(1, '#003366');
                ctx.fillStyle = wvGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                drawLandmasses(ctx, '#336699'); // Blue-grey for land
                drawClouds(ctx, 'rgba(200, 220, 255, ', 1.2, satelliteSeed + 3); // Blue-tinted clouds, unique seed
                drawGrid(ctx, 'rgba(255,255,255,0.2)'); // Add grid
                return new THREE.CanvasTexture(canvas);
            }

            function generateCloudClusterTexture(satelliteSeed) {
                const canvas = document.createElement('canvas');
                canvas.width = 2048;
                canvas.height = 1024;
                const ctx = canvas.getContext('2d');

                // Muted background for emphasis on clouds
                ctx.fillStyle = '#AAAAAA'; 
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                drawLandmasses(ctx, '#888888'); // Grey for land
                drawClouds(ctx, 'rgba(255, 255, 255, ', 2, satelliteSeed + 4); // Very dense, bright clouds, unique seed
                drawGrid(ctx, 'rgba(255,255,255,0.1)'); // Add grid
                return new THREE.CanvasTexture(canvas);
            }

            function updateGlobeTexture() {
                // Use a seed based on the current time and satellite for unique but consistent textures
                const satelliteSeed = new Date().getHours() + new Date().getMinutes() + currentSatellite.charCodeAt(0);
                let newTexture;
                switch (currentGlobeMode) {
                    case 'infrared':
                        newTexture = generateInfraredTexture(satelliteSeed);
                        break;
                    case 'water-vapor':
                        newTexture = generateWaterVaporTexture(satelliteSeed);
                        break;
                    case 'cloud-clusters':
                        newTexture = generateCloudClusterTexture(satelliteSeed);
                        break;
                    case 'visible':
                    default:
                        newTexture = generateVisibleTexture(satelliteSeed);
                        break;
                }
                
                if (earthMesh && earthMesh.material) {
                    if (earthMesh.material.map) {
                        earthMesh.material.map.dispose(); // Clean up old texture
                    }
                    earthMesh.material.map = newTexture;
                    earthMesh.material.needsUpdate = true;
                }
            }

            let currentAnalysisData = {}; // Store the latest analysis for download
            let historicalClusters = []; // Store clusters loaded from Firestore

            async function downloadRecentAnalysis() {
                const analysisText = `
TCC Algorithm Analysis Report - ${new Date().toLocaleString()}
Data Source: Simulated (Influenced by ${historicalClusters.length > 0 ? 'historical data' : 'random generation'})

--- Global TCC View ---
Current Globe Mode: ${currentGlobeMode}
Selected Satellite Data: ${currentSatellite}
Globe Center Lat: ${currentLatitudeSpan.textContent}¬∞
Globe Center Lon: ${currentLongitudeSpan.textContent}¬∞

--- Expected Outcomes Snapshot ---
Mean Temperature (Tb): ${meanTempElem.textContent}
Minimum Temperature (Tb): ${minTempElem.textContent}
Mean Radius: ${meanRadiusElem.textContent}
Mean Cloud Height: ${meanCloudHeightElem.textContent}

--- Identified Clusters (Simulated) ---
${currentAnalysisData.clusters ? currentAnalysisData.clusters.map(c => 
    `ID: ${c.id}, Lat: ${c.lat.toFixed(2)}, Lon: ${c.lon.toFixed(2)}, Size: ${c.size} km¬≤, Min Temp: ${c.minTemp} K, Status: ${c.status}`
).join('\n') : 'No clusters data available.'}

--- Climate Parameter Explorer (Simulated) ---
Sea Surface Temperature: ${document.getElementById('sst-value').textContent}¬∞C
Vertical Wind Shear: ${document.getElementById('wind-shear-value').textContent} m/s
Mid-Level Humidity: ${document.getElementById('humidity-value').textContent}%
Simulated TCC Activity Likelihood: ${document.getElementById('tcc-likelihood').textContent}

--- AI Model Training Metrics (Simulated) ---
Final Training Accuracy: ${currentAnalysisData.trainingMetrics ? currentAnalysisData.trainingMetrics.accuracy : 'N/A'}%
Final Training Loss: ${currentAnalysisData.trainingMetrics ? currentAnalysisData.trainingMetrics.loss : 'N/A'}
`;

                const blob = new Blob([analysisText], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `TCC_Analysis_Report_${new Date().toISOString().slice(0,10)}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url); // Clean up the URL object
            }

            // --- Identified Clusters Dashboard Logic (NEW) ---
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabContents = document.querySelectorAll('.tab-content');

            function showTab(tabId) {
                tabContents.forEach(content => {
                    content.classList.add('hidden');
                });
                tabButtons.forEach(button => {
                    button.classList.remove('active');
                });

                document.getElementById(`tab-content-${tabId}`).classList.remove('hidden');
                document.querySelector(`.tab-button[data-tab="${tabId}"]`).classList.add('active');

                // Render charts only when their tab is active
                if (tabId === 'temp-profile') {
                    renderTempProfileChart();
                } else if (tabId === 'training-metrics') {
                    renderTrainingMetricsChart();
                }
            }

            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    showTab(button.dataset.tab);
                });
            });

            // Initial tab display
            showTab('details');

            // --- Firestore Functions ---
            const TCC_HISTORY_COLLECTION = 'tcc_history';
            const MAX_HISTORY_RECORDS = 5; // Keep last 5 updates in Firestore

            async function saveClustersToFirestore(clusters) {
                if (!window.db || !window.userId) {
                    console.warn("Firestore not initialized or user not authenticated. Cannot save clusters.");
                    return;
                }
                try {
                    // Re-import necessary Firestore functions here
                    const { collection, query, orderBy, limit, addDoc, getDocs, deleteDoc, doc } = await import("https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js");
                    
                    const docRef = await addDoc(collection(window.db, `artifacts/${window.__app_id}/users/${window.userId}/${TCC_HISTORY_COLLECTION}`), {
                        timestamp: new Date(),
                        clusters: clusters
                    });
                    console.log("Clusters saved to Firestore with ID: ", docRef.id);

                    // Clean up old records to prevent excessive storage
                    const q = query(
                        collection(window.db, `artifacts/${window.__app_id}/users/${window.userId}/${TCC_HISTORY_COLLECTION}`),
                        orderBy('timestamp', 'desc'),
                        limit(MAX_HISTORY_RECORDS + 1) // Fetch one more than max to delete the oldest
                    );
                    const querySnapshot = await getDocs(q);
                    if (querySnapshot.docs.length > MAX_HISTORY_RECORDS) {
                        const oldestDoc = querySnapshot.docs[querySnapshot.docs.length - 1];
                        await deleteDoc(doc(window.db, `artifacts/${window.__app_id}/users/${window.userId}/${TCC_HISTORY_COLLECTION}`, oldestDoc.id));
                        console.log("Deleted oldest TCC history record:", oldestDoc.id);
                    }

                } catch (e) {
                    console.error("Error saving clusters to Firestore: ", e);
                }
            }

            async function loadHistoricalClusters() {
                if (!window.db || !window.userId) {
                    console.warn("Firestore not initialized or user not authenticated. Cannot load historical clusters.");
                    historicalClusters = [];
                    return;
                }
                showLoading("Loading historical data...");
                try {
                    // Re-import functions here to ensure they are in scope
                    const { collection, query, orderBy, limit, getDocs } = await import("https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js");

                    const q = query(
                        collection(window.db, `artifacts/${window.__app_id}/users/${window.userId}/${TCC_HISTORY_COLLECTION}`),
                        orderBy('timestamp', 'desc'),
                        limit(1) // Get only the most recent record
                    );
                    const querySnapshot = await getDocs(q);
                    if (!querySnapshot.empty) {
                        historicalClusters = querySnapshot.docs[0].data().clusters;
                        console.log("Loaded historical clusters:", historicalClusters);
                    } else {
                        historicalClusters = [];
                        console.log("No historical clusters found.");
                    }
                } catch (e) {
                    console.error("Error loading historical clusters from Firestore: ", e);
                    historicalClusters = [];
                } finally {
                    hideLoading();
                }
            }

            async function clearHistoricalData() {
                if (!window.db || !window.userId) {
                    console.warn("Firestore not initialized or user not authenticated. Cannot clear historical data.");
                    return;
                }
                showLoading("Clearing historical data...");
                try {
                    // Re-import functions here
                    const { collection, query, getDocs, deleteDoc, doc } = await import("https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js");
                    
                    const q = query(collection(window.db, `artifacts/${window.__app_id}/users/${window.userId}/${TCC_HISTORY_COLLECTION}`));
                    const querySnapshot = await getDocs(q);
                    const deletePromises = querySnapshot.docs.map(docToDelete => deleteDoc(doc(window.db, `artifacts/${window.__app_id}/users/${window.userId}/${TCC_HISTORY_COLLECTION}`, docToDelete.id)));
                    await Promise.all(deletePromises);
                    historicalClusters = [];
                    console.log("All historical data cleared.");
                } catch (e) {
                    console.error("Error clearing historical data:", e);
                } finally {
                    hideLoading();
                    updateAllData(); // Re-run update to regenerate clusters
                }
            }

            // Simulate TCC Cluster Data (enhanced with historical influence)
            function generateSimulatedClusters(count, satellite) {
                const statuses = ['Active', 'Developing', 'Dissipated'];
                const clusters = [];
                let latRange = 60; // Default tropical range (-30 to 30)
                let lonOffset = 0; // Default offset

                // Adjust simulation based on satellite (simplified)
                if (satellite === 'GOES-16') { // Covers Americas
                    lonOffset = -90; // Centered roughly over Americas
                } else if (satellite === 'Himawari-8') { // Covers Asia-Pacific
                    lonOffset = 140; // Centered roughly over Asia-Pacific
                } else if (satellite === 'Meteosat-11') { // Covers Europe/Africa
                    lonOffset = 0; // Centered roughly over Prime Meridian
                } else { // INSAT-3D (Indian Ocean region)
                    lonOffset = 75; // Centered roughly over Indian Ocean
                }

                // Calculate average characteristics of recent active/developing clusters from history
                let avgLat = 0, avgLon = 0, avgSize = 0, avgMinTemp = 0, avgMeanTemp = 0, avgMaxCloudHeight = 0;
                let activeHistoricalCount = 0;

                if (historicalClusters.length > 0) {
                    historicalClusters.forEach(c => {
                        if (c.status === 'Active' || c.status === 'Developing') {
                            avgLat += parseFloat(c.lat);
                            avgLon += parseFloat(c.lon);
                            avgSize += parseFloat(c.size);
                            avgMinTemp += parseFloat(c.minTemp);
                            avgMeanTemp += parseFloat(c.meanTemp);
                            avgMaxCloudHeight += parseFloat(c.maxCloudHeight);
                            activeHistoricalCount++;
                        }
                    });

                    if (activeHistoricalCount > 0) {
                        avgLat /= activeHistoricalCount;
                        avgLon /= activeHistoricalCount;
                        avgSize /= activeHistoricalCount;
                        avgMinTemp /= activeHistoricalCount;
                        avgMeanTemp /= activeHistoricalCount;
                        avgMaxCloudHeight /= activeHistoricalCount;
                    }
                }

                for (let i = 0; i < count; i++) {
                    let newLat, newLon, newSize, newMinTemp, newMeanTemp, newMaxCloudHeight;

                    // Influence new cluster generation by historical data if available
                    if (activeHistoricalCount > 0 && Math.random() < 0.7) { // 70% chance to be influenced
                        newLat = (avgLat + (Math.random() * 20 - 10)).toFixed(2); // +/- 10 degrees from avg
                        newLon = (avgLon + (Math.random() * 20 - 10)).toFixed(2); // +/- 10 degrees from avg
                        newSize = (avgSize * (0.8 + Math.random() * 0.4)).toFixed(0); // +/- 20% from avg
                        newMinTemp = (avgMinTemp * (0.95 + Math.random() * 0.1)).toFixed(1); // +/- 5% from avg
                        newMeanTemp = (avgMeanTemp * (0.95 + Math.random() * 0.1)).toFixed(1); // +/- 5% from avg
                        newMaxCloudHeight = (avgMaxCloudHeight * (0.9 + Math.random() * 0.2)).toFixed(1); // +/- 10% from avg
                    } else { // Random generation
                        newLat = (Math.random() * latRange - latRange / 2).toFixed(2);
                        newLon = ((Math.random() * 60 - 30) + lonOffset).toFixed(2);
                        newSize = (30000 + Math.random() * 100000).toFixed(0);
                        newMinTemp = (190 + Math.random() * 20).toFixed(1);
                        newMeanTemp = (210 + Math.random() * 20).toFixed(1);
                        newMaxCloudHeight = (10 + Math.random() * 8).toFixed(1);
                    }

                    // Clamp values to reasonable ranges after influence
                    newLat = Math.max(-30, Math.min(30, parseFloat(newLat))).toFixed(2);
                    newLon = Math.max(-180, Math.min(180, parseFloat(newLon))).toFixed(2);
                    newSize = Math.max(34800, Math.min(200000, parseFloat(newSize))).toFixed(0);
                    newMinTemp = Math.max(180, Math.min(210, parseFloat(newMinTemp))).toFixed(1);
                    newMeanTemp = Math.max(200, Math.min(230, parseFloat(newMeanTemp))).toFixed(1);
                    newMaxCloudHeight = Math.max(10, Math.min(18, parseFloat(newMaxCloudHeight))).toFixed(1);


                    clusters.push({
                        id: `TCC-${Math.floor(Math.random() * 10000)}`,
                        lat: newLat,
                        lon: newLon,
                        size: newSize,
                        minTemp: newMinTemp,
                        meanTemp: newMeanTemp,
                        maxCloudHeight: newMaxCloudHeight,
                        status: statuses[Math.floor(Math.random() * statuses.length)] // Random status
                    });
                }
                return clusters;
            }

            // Function to handle the AI TCC Forecast logic
            async function getTccForecast(cluster, climateParams) {
                showLoading("Generating AI forecast...");
                
                const prompt = `You are a professional meteorologist. Analyze the following data for a Tropical Cloud Cluster (TCC) and provide a short, clear forecast of its potential development. Consider its current state and the environmental conditions.

TCC Data:
- ID: ${cluster.id}
- Location: ${cluster.lat}¬∞ Lat, ${cluster.lon}¬∞ Lon
- Current Status: ${cluster.status}
- Size: ${cluster.size} km¬≤
- Minimum Temperature: ${cluster.minTemp} K (lower temperature indicates higher clouds/strength)
- Mean Temperature: ${cluster.meanTemp} K
- Maximum Cloud Height: ${cluster.maxCloudHeight} km

Current Environmental Conditions:
- Sea Surface Temperature: ${climateParams.sst} ¬∞C (high temperature can fuel storms)
- Vertical Wind Shear: ${climateParams.windShear} m/s (low shear allows for development)
- Mid-Level Humidity: ${climateParams.humidity} % (high humidity provides moisture for growth)

Provide a forecast in no more than three sentences. Use professional, but easy-to-understand language.`;

                try {
                    let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
                    const payload = { contents: chatHistory };
                    const apiKey = "";
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`API error: ${response.status} - ${errorData.error.message || 'Unknown error'}`);
                    }

                    const result = await response.json();
                    const text = result.candidates?.[0]?.content?.parts?.[0]?.text || "Sorry, I couldn't generate a forecast for this TCC.";
                    return text;
                } catch (error) {
                    console.error("Error generating AI forecast:", error);
                    return `An error occurred while generating the forecast: ${error.message}`;
                } finally {
                    hideLoading();
                }
            }


            function renderClusterDetails(clusters) {
                const clusterListDiv = document.getElementById('cluster-list');
                clusterListDiv.innerHTML = ''; // Clear previous clusters

                if (clusters.length === 0) {
                    clusterListDiv.innerHTML = '<p class="text-center text-gray-600 col-span-full">No TCCs identified in the recent update.</p>';
                    return;
                }

                clusters.forEach(cluster => {
                    const statusColor = {
                        'Active': 'text-green-600',
                        'Developing': 'text-yellow-600',
                        'Dissipated': 'text-red-600'
                    }[cluster.status] || 'text-gray-600';

                    const clusterCard = `
                        <div class="bg-sky-50 p-4 rounded-lg shadow-sm border border-sky-100">
                            <h4 class="font-bold text-sky-700 text-lg mb-2">${cluster.id}</h4>
                            <p class="text-sm text-gray-600">Lat/Lon: ${cluster.lat}¬∞ / ${cluster.lon}¬∞</p>
                            <p class="text-sm text-gray-600">Area: ${cluster.size} km¬≤</p>
                            <p class="text-sm text-gray-600">Min Temp: ${cluster.minTemp} K</p>
                            <p class="text-sm text-gray-600">Mean Temp: ${cluster.meanTemp} K</p>
                            <p class="text-sm text-gray-600">Max Cloud Height: ${cluster.maxCloudHeight} km</p>
                            <p class="text-sm font-semibold ${statusColor}">Status: ${cluster.status}</p>
                            <div id="forecast-output-${cluster.id}" class="mt-4 p-3 bg-white rounded-lg text-gray-700 text-sm italic hidden"></div>
                            <button data-cluster-id="${cluster.id}" class="ai-forecast-btn mt-4 w-full bg-orange-500 hover:bg-orange-600 text-white font-bold py-2 px-4 rounded-full text-sm shadow-md transition-transform transform hover:scale-105 flex items-center justify-center">
                                ‚ú® AI TCC Forecast ‚ú®
                            </button>
                        </div>
                    `;
                    clusterListDiv.insertAdjacentHTML('beforeend', clusterCard);
                });

                // Add event listeners for the new forecast buttons
                document.querySelectorAll('.ai-forecast-btn').forEach(button => {
                    button.addEventListener('click', async (event) => {
                        const clusterId = event.target.dataset.clusterId;
                        const cluster = clusters.find(c => c.id === clusterId);

                        const forecastOutputElem = document.getElementById(`forecast-output-${clusterId}`);
                        
                        event.target.disabled = true;
                        event.target.innerHTML = 'Generating...';

                        const climateParams = {
                            sst: parseFloat(sstSlider.value),
                            windShear: parseFloat(windShearSlider.value),
                            humidity: parseFloat(humiditySlider.value)
                        };

                        const forecastText = await getTccForecast(cluster, climateParams);
                        
                        forecastOutputElem.textContent = forecastText;
                        forecastOutputElem.classList.remove('hidden');
                        
                        event.target.disabled = false;
                        event.target.innerHTML = '‚ú® AI TCC Forecast ‚ú®';
                    });
                });
            }

            let tempProfileChartInstance;
            function renderTempProfileChart() {
                const ctx = document.getElementById('tempProfileChart').getContext('2d');
                if (tempProfileChartInstance) {
                    tempProfileChartInstance.destroy();
                }

                // Simulated temperature profile data
                const altitudes = [0, 2, 4, 6, 8, 10, 12, 14, 16]; // km
                const temperatures = [295, 280, 265, 250, 235, 220, 210, 200, 195]; // K (simulated troposphere/lower stratosphere)

                tempProfileChartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: altitudes.map(a => `${a} km`),
                        datasets: [{
                            label: 'Temperature (Kelvin)',
                            data: temperatures,
                            borderColor: '#0ea5e9',
                            backgroundColor: 'rgba(14, 165, 233, 0.2)',
                            fill: true,
                            tension: 0.3,
                            pointRadius: 5,
                            pointBackgroundColor: '#0ea5e9'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Simulated Vertical Temperature Profile of a TCC',
                                color: '#0c4a6e'
                            },
                            legend: {
                                display: false
                            }
                        },
                        scales: {
                            y: {
                                title: {
                                    display: true,
                                    text: 'Altitude (km)',
                                    color: '#075985'
                                },
                                reverse: false, // Altitude increases upwards
                                ticks: {
                                    callback: function(value) {
                                        return `${value} km`;
                                    }
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Temperature (Kelvin)',
                                    color: '#075985'
                                }
                            }
                        }
                    }
                });
            }

            // Climate Parameter Explorer Logic
            const sstSlider = document.getElementById('sst-slider');
            const sstValue = document.getElementById('sst-value');
            const windShearSlider = document.getElementById('wind-shear-slider');
            const windShearValue = document.getElementById('wind-shear-value');
            const humiditySlider = document.getElementById('humidity-slider');
            const humidityValue = document.getElementById('humidity-value');
            const tccLikelihood = document.getElementById('tcc-likelihood');

            function updateTCCLikelihood() {
                const sst = parseFloat(sstSlider.value);
                const windShear = parseFloat(windShearSlider.value);
                const humidity = parseFloat(humiditySlider.value);

                sstValue.textContent = sst.toFixed(1);
                windShearValue.textContent = windShear.toFixed(1);
                humidityValue.textContent = humidity.toFixed(0);

                // Simple heuristic for likelihood (simulated)
                let likelihoodScore = 0;
                if (sst >= 27.5) likelihoodScore += 2;
                else if (sst >= 26) likelihoodScore += 1;

                if (windShear <= 8) likelihoodScore += 2;
                else if (windShear <= 12) likelihoodScore += 1;

                if (humidity >= 75) likelihoodScore += 2;
                else if (humidity >= 65) likelihoodScore += 1;

                let likelihoodText = '';
                if (likelihoodScore >= 5) likelihoodText = 'Very High';
                else if (likelihoodScore >= 3) likelihoodText = 'High';
                else if (likelihoodScore >= 1) likelihoodText = 'Moderate';
                else likelihoodText = 'Low';

                tccLikelihood.textContent = likelihoodText;
            }

            sstSlider.addEventListener('input', updateTCCLikelihood);
            windShearSlider.addEventListener('input', updateTCCLikelihood);
            humiditySlider.addEventListener('input', updateTCCLikelihood);

            updateTCCLikelihood(); // Initial update

            let trainingMetricsChartInstance;
            let currentEpoch = 0;
            function renderTrainingMetricsChart() {
                const ctx = document.getElementById('trainingMetricsChart').getContext('2d');
                if (trainingMetricsChartInstance) {
                    trainingMetricsChartInstance.destroy();
                }

                // Simulated training data - now showing consistent improvement
                // We'll simulate a continuous improvement over "epochs" (updates)
                currentEpoch++; // Increment epoch with each update

                const epochs = Array.from({ length: currentEpoch }, (_, i) => i + 1);
                
                // Simulate improving accuracy and F1-score, decreasing loss
                // Ensure values stay within reasonable bounds (e.g., accuracy 0-100, loss > 0)
                const accuracy = epochs.map(e => Math.min(98, (70 + e * 2 + Math.random() * 5)).toFixed(2));
                const loss = epochs.map(e => Math.max(0.1, (5 - e * 0.3 - Math.random() * 0.5)).toFixed(2));
                const f1Score = epochs.map(e => Math.min(0.95, (0.6 + e * 0.03 + Math.random() * 0.05)).toFixed(2));

                trainingMetricsChartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: epochs.map(e => `Epoch ${e}`),
                        datasets: [
                            {
                                label: 'Accuracy (%)',
                                data: accuracy,
                                borderColor: '#10b981', // green-500
                                backgroundColor: 'rgba(16, 185, 129, 0.2)',
                                fill: false,
                                tension: 0.3,
                                pointRadius: 4,
                            },
                            {
                                label: 'Loss',
                                data: loss,
                                borderColor: '#ef4444', // red-500
                                backgroundColor: 'rgba(239, 68, 68, 0.2)',
                                fill: false,
                                tension: 0.3,
                                pointRadius: 4,
                                yAxisID: 'y1' // Use a second Y-axis for loss
                            },
                            {
                                label: 'F1-Score',
                                data: f1Score,
                                borderColor: '#3b82f6', // blue-500
                                backgroundColor: 'rgba(59, 130, 246, 0.2)',
                                fill: false,
                                tension: 0.3,
                                pointRadius: 4,
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Simulated AI Model Training Performance (Improving with Data)',
                                color: '#0c4a6e'
                            },
                            legend: {
                                position: 'bottom'
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Accuracy / F1-Score',
                                    color: '#075985'
                                },
                                max: 100, // For accuracy
                                ticks: {
                                    callback: function(value) {
                                        return value + (this.id === 'y' ? '%' : ''); // Add % for accuracy
                                    }
                                }
                            },
                            y1: { // Second Y-axis for Loss
                                type: 'linear',
                                position: 'right',
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Loss',
                                    color: '#075985'
                                },
                                grid: {
                                    drawOnChartArea: false // Only draw grid lines for the first Y-axis
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Epoch',
                                    color: '#075985'
                                }
                            }
                        }
                    }
                });

                // Store training metrics for download
                currentAnalysisData.trainingMetrics = {
                    accuracy: accuracy[accuracy.length - 1],
                    loss: loss[loss.length - 1],
                    f1Score: f1Score[f1Score.length - 1]
                };
            }


            // --- Main Update Function ---
            async function updateAllData() {
                showLoading("Updating analysis data...");
                updateGlobeTexture();
                updateTCCDashboardData();
                
                // Generate and render simulated clusters based on selected satellite AND historical data
                const simulatedClusters = generateSimulatedClusters(Math.floor(Math.random() * 5) + 3, currentSatellite); // 3 to 7 clusters
                renderClusterDetails(simulatedClusters);
                currentAnalysisData.clusters = simulatedClusters; // Store for download

                lastUpdatedSpan.textContent = new Date().toLocaleTimeString();
                
                // Save the newly generated clusters to Firestore
                if (window.isAuthReady && window.db && window.userId) {
                    await saveClustersToFirestore(simulatedClusters);
                } else {
                    console.warn("Firestore not ready, skipping save operation.");
                }
                hideLoading();
            }

            // Initialize Globe (moved here to ensure Three.js is loaded)
            initGlobe();
            // The rest of the initialization and updates will happen after firebaseAuthReady event
        });
    </script>
</body>
</html>
